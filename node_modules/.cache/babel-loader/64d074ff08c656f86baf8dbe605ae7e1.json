{"ast":null,"code":"/*\n * \n * The p5.EasyCam library - Easy 3D CameraControl for p5.js and WEBGL.\n *\n *   Copyright Â© 2017-2021 by p5.EasyCam authors\n *\n *   Source: https://github.com/freshfork/p5.EasyCam\n *\n *   MIT License: https://opensource.org/licenses/MIT\n * \n * \n * explanatory notes:\n * \n * p5.EasyCam is a derivative of the original PeasyCam Library by Jonathan Feinberg \n * and combines new useful features with the great look and feel of its parent.\n * \n */\n'use strict';\n/** @namespace  */\n\nvar Dw = function (ext) {\n  /**\n   * EasyCam Library Info\n   */\n  const INFO = {\n    /** name    */\n    LIBRARY: \"p5.EasyCam\",\n\n    /** version */\n    VERSION: \"1.2.0\",\n\n    /** author  */\n    AUTHOR: \"p5.EasyCam authors\",\n\n    /** source  */\n    SOURCE: \"https://github.com/freshfork/p5.EasyCam\",\n    toString: function () {\n      return this.LIBRARY + \" v\" + this.VERSION + \" by \" + this.AUTHOR + \" (\" + this.SOURCE + \")\";\n    }\n  };\n  /**\n   * EasyCam\n   *\n   * <pre>\n   *\n   *   new Dw.EasyCam(p5.RendererGL, {\n   *     distance : z,                 // scalar\n   *     center   : [x, y, z],         // vector\n   *     rotation : [q0, q1, q2, q3],  // quaternion\n   *     viewport : [x, y, w, h],      // array\n   *   }\n   *\n   * </pre>\n   *\n   * @param {p5.RendererGL} renderer - p5 WEBGL renderer\n   * @param {Object}        args     - {distance, center, rotation, viewport}\n   *\n   */\n\n  class EasyCam {\n    /**\n     * @constructor\n     */\n    constructor(renderer, args) {\n      // WEBGL renderer required\n      if (!(renderer instanceof p5.RendererGL)) {\n        console.log(\"renderer needs to be an instance of p5.RendererGL\");\n        return;\n      }\n\n      var bounds = renderer.elt.getBoundingClientRect(); // define default args\n\n      args = args || {};\n      if (args.distance === undefined) args.distance = 500;\n      if (args.center === undefined) args.center = [0, 0, 0];\n      if (args.rotation === undefined) args.rotation = Rotation.identity();\n      if (args.viewport === undefined) args.viewport = [0, 0, renderer.width, renderer.height];\n      if (args.offset === undefined) args.offset = [bounds.x + window.scrollX, bounds.y + window.scrollY]; // library info\n\n      this.INFO = INFO; // set renderer, graphics, p5\n      // this.renderer;\n      // this.graphics;\n      // this.P5\n\n      this.setCanvas(renderer); // self reference\n\n      var cam = this;\n      this.cam = cam; // some constants\n\n      this.LOOK = [0, 0, 1];\n      this.UP = [0, 1, 0]; // principal axes flags\n\n      this.AXIS = new function () {\n        this.YAW = 0x01;\n        this.PITCH = 0x02;\n        this.ROLL = 0x04;\n        this.ALL = this.YAW | this.PITCH | this.ROLL;\n      }(); // mouse action constraints\n\n      this.SHIFT_CONSTRAINT = 0; // applied when pressing the shift key\n\n      this.FIXED_CONSTRAINT = 0; // applied, when set by user and SHIFT_CONSTRAINT is 0\n\n      this.DRAG_CONSTRAINT = 0; // depending on SHIFT_CONSTRAINT and FIXED_CONSTRAINT, default is ALL\n      // mouse action speed\n\n      this.scale_rotation = 0.001;\n      this.scale_pan = 0.0002;\n      this.scale_zoom = 0.001;\n      this.scale_zoomwheel = 20.0; // zoom limits\n\n      this.distance_min_limit = 0.01;\n      this.distance_min = 1.0;\n      this.distance_max = Number.MAX_VALUE; // main state\n\n      this.state = {\n        distance: args.distance,\n        // scalar\n        center: args.center.slice(),\n        // vec3\n        rotation: args.rotation.slice(),\n        // quaternion\n        copy: function (dst) {\n          dst = dst || {};\n          dst.distance = this.distance;\n          dst.center = this.center.slice();\n          dst.rotation = this.rotation.slice();\n          return dst;\n        }\n      }; // backup-state at start\n\n      this.state_reset = this.state.copy(); // backup-state, probably not required\n\n      this.state_pushed = this.state.copy(); // viewport for the mouse-pointer [x,y,w,h]\n\n      this.viewport = args.viewport.slice(); // offset of the canvas in the container\n\n      this.offset = args.offset.slice(); // add a handler for window resizing\n\n      window.addEventListener('resize', function (e) {\n        let p = renderer.elt.getBoundingClientRect();\n        cam.offset = [p.x + window.scrollX, p.y + window.scrollY];\n      }); // mouse/touch/key action handler\n\n      this.mouse = {\n        cam: cam,\n        curr: [0, 0, 0],\n        prev: [0, 0, 0],\n        dist: [0, 0, 0],\n        mwheel: 0,\n        isPressed: false,\n        // true if (istouchdown || ismousedown)\n        istouchdown: false,\n        // true, if input came from a touch\n        ismousedown: false,\n        // true, if input came from a mouse\n        BUTTON: {\n          LMB: 0x01,\n          MMB: 0x02,\n          RMB: 0x04\n        },\n        button: 0,\n        mouseDragLeft: cam.mouseDragRotate.bind(cam),\n        mouseDragCenter: cam.mouseDragPan.bind(cam),\n        mouseDragRight: cam.mouseDragZoom.bind(cam),\n        mouseWheelAction: cam.mouseWheelZoom.bind(cam),\n        touchmoveSingle: cam.mouseDragRotate.bind(cam),\n        touchmoveMulti: function () {\n          cam.mouseDragPan();\n          cam.mouseDragZoom();\n        },\n        insideViewport: function (x, y) {\n          var x0 = cam.viewport[0],\n              x1 = x0 + cam.viewport[2];\n          var y0 = cam.viewport[1],\n              y1 = y0 + cam.viewport[3];\n          return x > x0 && x < x1 && y > y0 && y < y1;\n        },\n        solveConstraint: function () {\n          var dx = this.dist[0];\n          var dy = this.dist[1]; // YAW, PITCH\n\n          if (this.shiftKey && !cam.SHIFT_CONSTRAINT && Math.abs(dx - dy) > 1) {\n            cam.SHIFT_CONSTRAINT = Math.abs(dx) > Math.abs(dy) ? cam.AXIS.YAW : cam.AXIS.PITCH;\n          } // define constraint by increasing priority\n\n\n          cam.DRAG_CONSTRAINT = cam.AXIS.ALL;\n          if (cam.FIXED_CONSTRAINT) cam.DRAG_CONSTRAINT = cam.FIXED_CONSTRAINT;\n          if (cam.SHIFT_CONSTRAINT) cam.DRAG_CONSTRAINT = cam.SHIFT_CONSTRAINT;\n        },\n        updateInput: function (x, y, z) {\n          var mouse = cam.mouse;\n          var pd = cam.P5.pixelDensity();\n          mouse.prev[0] = mouse.curr[0];\n          mouse.prev[1] = mouse.curr[1];\n          mouse.prev[2] = mouse.curr[2];\n          mouse.curr[0] = x;\n          mouse.curr[1] = y;\n          mouse.curr[2] = z;\n          mouse.dist[0] = -(mouse.curr[0] - mouse.prev[0]) / pd;\n          mouse.dist[1] = -(mouse.curr[1] - mouse.prev[1]) / pd;\n          mouse.dist[2] = -(mouse.curr[2] - mouse.prev[2]) / pd;\n        },\n        //////////////////////////////////////////////////////////////////////////\n        // mouseinput\n        //////////////////////////////////////////////////////////////////////////\n        mousedown: function (event) {\n          var mouse = cam.mouse; // Account for canvas shift:\n\n          var offX = cam.offset[0] - window.scrollX,\n              offY = cam.offset[1] - window.scrollY;\n          if (event.button === 0) mouse.button |= mouse.BUTTON.LMB;\n          if (event.button === 1) mouse.button |= mouse.BUTTON.MMB;\n          if (event.button === 2) mouse.button |= mouse.BUTTON.RMB;\n\n          if (mouse.insideViewport(event.x - offX, event.y - offY)) {\n            mouse.updateInput(event.x - offX, event.y - offY, event.y - offY);\n            mouse.ismousedown = mouse.button > 0;\n            mouse.isPressed = mouse.ismousedown;\n            cam.SHIFT_CONSTRAINT = 0;\n          }\n        },\n        mousedrag: function () {\n          var pd = cam.P5.pixelDensity();\n          var mouse = cam.mouse;\n\n          if (mouse.ismousedown) {\n            var x = cam.P5.mouseX;\n            var y = cam.P5.mouseY;\n            var z = y;\n            mouse.updateInput(x, y, z);\n            mouse.solveConstraint();\n            var LMB = mouse.button & mouse.BUTTON.LMB;\n            var MMB = mouse.button & mouse.BUTTON.MMB;\n            var RMB = mouse.button & mouse.BUTTON.RMB;\n            if (LMB && mouse.mouseDragLeft) mouse.mouseDragLeft();\n            if (MMB && mouse.mouseDragCenter) mouse.mouseDragCenter();\n            if (RMB && mouse.mouseDragRight) mouse.mouseDragRight();\n          }\n        },\n        mouseup: function (event) {\n          var mouse = cam.mouse;\n          if (event.button === 0) mouse.button &= ~mouse.BUTTON.LMB;\n          if (event.button === 1) mouse.button &= ~mouse.BUTTON.MMB;\n          if (event.button === 2) mouse.button &= ~mouse.BUTTON.RMB;\n          mouse.ismousedown = mouse.button > 0;\n          mouse.isPressed = mouse.istouchdown || mouse.ismousedown;\n          cam.SHIFT_CONSTRAINT = 0;\n        },\n        dblclick: function (event) {\n          // Account for canvas shift:\n          var offX = cam.offset[0] - window.scrollX,\n              offY = cam.offset[1] - window.scrollY;\n\n          if (cam.mouse.insideViewport(event.x - offX, event.y - offY)) {\n            cam.reset();\n          }\n        },\n        wheel: function (event) {\n          var x = event.x;\n          var y = event.y;\n          var mouse = cam.mouse;\n\n          if (mouse.insideViewport(x, y)) {\n            mouse.mwheel = event.deltaY * 0.01;\n            if (mouse.mouseWheelAction) mouse.mouseWheelAction();\n          }\n        },\n        //////////////////////////////////////////////////////////////////////////\n        // touchinput\n        //////////////////////////////////////////////////////////////////////////\n        evaluateTouches: function (event) {\n          var touches = event.touches;\n          var avg_x = 0.0;\n          var avg_y = 0.0;\n          var avg_d = 0.0;\n          var i,\n              dx,\n              dy,\n              count = touches.length; // Account for canvas shift:\n\n          var offX = cam.offset[0] - window.scrollX,\n              offY = cam.offset[1] - window.scrollY; // center, averaged touch position\n\n          for (i = 0; i < count; i++) {\n            avg_x += touches[i].clientX - offX;\n            avg_y += touches[i].clientY - offY;\n          }\n\n          avg_x /= count;\n          avg_y /= count; // offset, mean distance to center\n\n          for (i = 0; i < count; i++) {\n            dx = avg_x - (touches[i].clientX - offX);\n            dy = avg_y - (touches[i].clientY - offY);\n            avg_d += Math.sqrt(dx * dx + dy * dy);\n          }\n\n          avg_d /= count;\n          cam.mouse.updateInput(avg_x, avg_y, -avg_d);\n        },\n        touchstart: function (event) {\n          event.preventDefault();\n          event.stopPropagation();\n          var mouse = cam.mouse;\n          mouse.evaluateTouches(event);\n          mouse.istouchdown = mouse.insideViewport(mouse.curr[0], mouse.curr[1]);\n          mouse.isPressed = cam.mouse.istouchdown || cam.mouse.ismousedown;\n          mouse.dbltap(event);\n        },\n        touchmove: function (event) {\n          event.preventDefault();\n          event.stopPropagation();\n          var mouse = cam.mouse;\n\n          if (mouse.istouchdown) {\n            mouse.evaluateTouches(event);\n            mouse.solveConstraint();\n\n            if (event.touches.length === 1) {\n              mouse.touchmoveSingle();\n            } else {\n              mouse.touchmoveMulti();\n              mouse.tapcount = 0;\n            }\n          }\n        },\n        touchend: function (event) {\n          event.preventDefault();\n          event.stopPropagation();\n          var mouse = cam.mouse;\n          mouse.istouchdown = false, mouse.isPressed = mouse.istouchdown || mouse.ismousedown;\n          cam.SHIFT_CONSTRAINT = 0;\n\n          if (mouse.tapcount >= 2) {\n            if (mouse.insideViewport(mouse.curr[0], mouse.curr[1])) {\n              cam.reset();\n            }\n\n            mouse.tapcount = 0;\n          }\n        },\n        tapcount: 0,\n        dbltap: function (event) {\n          if (cam.mouse.tapcount++ == 0) {\n            setTimeout(function () {\n              cam.mouse.tapcount = 0;\n            }, 350);\n          }\n        },\n        //////////////////////////////////////////////////////////////////////////\n        // keyingput\n        //////////////////////////////////////////////////////////////////////////\n        // key-event for shift constraints\n        shiftKey: false,\n        keydown: function (event) {\n          var mouse = cam.mouse;\n\n          if (!mouse.shiftKey) {\n            mouse.shiftKey = event.keyCode === 16;\n          }\n        },\n        keyup: function (event) {\n          var mouse = cam.mouse;\n\n          if (mouse.shiftKey) {\n            mouse.shiftKey = event.keyCode !== 16;\n\n            if (!mouse.shiftKey) {\n              cam.SHIFT_CONSTRAINT = 0;\n            }\n          }\n        }\n      }; // camera mouse listeners\n\n      this.attachMouseListeners(); // P5 registered callbacks, TODO unregister on dispose\n\n      this.auto_update = true;\n      this.P5.registerMethod('pre', function () {\n        if (cam.auto_update) {\n          cam.update();\n        }\n      }); // damped camera transition\n\n      this.dampedZoom = new DampedAction(function (d) {\n        cam.zoom(d * cam.getZoomMult());\n      });\n      this.dampedPanX = new DampedAction(function (d) {\n        cam.panX(d * cam.getPanMult());\n      });\n      this.dampedPanY = new DampedAction(function (d) {\n        cam.panY(d * cam.getPanMult());\n      });\n      this.dampedRotX = new DampedAction(function (d) {\n        cam.rotateX(d * cam.getRotationMult());\n      });\n      this.dampedRotY = new DampedAction(function (d) {\n        cam.rotateY(d * cam.getRotationMult());\n      });\n      this.dampedRotZ = new DampedAction(function (d) {\n        cam.rotateZ(d * cam.getRotationMult());\n      }); // interpolated camera transition\n\n      this.timedRot = new Interpolation(cam.setInterpolatedRotation.bind(cam));\n      this.timedPan = new Interpolation(cam.setInterpolatedCenter.bind(cam));\n      this.timedzoom = new Interpolation(cam.setInterpolatedDistance.bind(cam));\n    }\n    /**\n     * sets the WEBGL renderer the camera is working on\n     *\n     * @param {p5.RendererGL} renderer ... p5 WEBGL renderer\n     */\n\n\n    setCanvas(renderer) {\n      if (renderer instanceof p5.RendererGL) {\n        // p5js seems to be not very clear about this\n        // ... a bit confusing, so i guess this could change in future releases\n        this.renderer = renderer;\n\n        if (renderer._pInst instanceof p5) {\n          this.graphics = renderer;\n        } else {\n          this.graphics = renderer._pInst;\n        }\n\n        this.P5 = this.graphics._pInst;\n      } else {\n        this.graphics = undefined;\n        this.renderer = undefined;\n      }\n    }\n    /** @return {p5.RendererGL} the currently used renderer */\n\n\n    getCanvas() {\n      return this.renderer;\n    }\n\n    attachListener(el, ev, fx, op) {\n      if (!el || el === fx.el) {\n        return;\n      }\n\n      this.detachListener(fx);\n      fx.el = el;\n      fx.ev = ev;\n      fx.op = op;\n      fx.el.addEventListener(fx.ev, fx, fx.op);\n    }\n\n    detachListener(fx) {\n      if (fx.el) {\n        fx.el.removeEventListener(fx.ev, fx, fx.op);\n        fx.el = undefined;\n      }\n    }\n    /** attaches input-listeners (mouse, touch, key) to the used renderer */\n\n\n    attachMouseListeners(renderer) {\n      var cam = this.cam;\n      var mouse = cam.mouse;\n      renderer = renderer || cam.renderer;\n\n      if (renderer) {\n        var op = {\n          passive: false\n        };\n        var el = renderer.elt;\n        cam.attachListener(el, 'mousedown', mouse.mousedown, op);\n        cam.attachListener(el, 'mouseup', mouse.mouseup, op);\n        cam.attachListener(el, 'dblclick', mouse.dblclick, op);\n        cam.attachListener(el, 'wheel', mouse.wheel, op);\n        cam.attachListener(el, 'touchstart', mouse.touchstart, op);\n        cam.attachListener(el, 'touchend', mouse.touchend, op);\n        cam.attachListener(el, 'touchmove', mouse.touchmove, op);\n        cam.attachListener(window, 'keydown', mouse.keydown, op);\n        cam.attachListener(window, 'keyup', mouse.keyup, op);\n      }\n    }\n    /** detaches all attached input-listeners */\n\n\n    removeMouseListeners() {\n      var cam = this.cam;\n      var mouse = cam.mouse;\n      cam.detachListener(mouse.mousedown);\n      cam.detachListener(mouse.mouseup);\n      cam.detachListener(mouse.dblclick);\n      cam.detachListener(mouse.wheel);\n      cam.detachListener(mouse.keydown);\n      cam.detachListener(mouse.keyup);\n      cam.detachListener(mouse.touchstart);\n      cam.detachListener(mouse.touchend);\n      cam.detachListener(mouse.touchmove);\n    }\n    /** Disposes/releases the camera. */\n\n\n    dispose() {\n      // TODO: p5 unregister 'pre', ... not available in 0.5.16\n      removeMouseListeners();\n    }\n    /** @return {boolean} the current autoUpdate state */\n\n\n    getAutoUpdate() {\n      return this.auto_update;\n    }\n    /** \n     * If true, the EasyCam will update automatically in a pre-draw step.\n     * This updates the camera state and updates the renderers \n     * modelview/camera matrix.\n     *\n     * If false, the update() needs to be called manually.\n     *\n     * @param {boolean} the new autoUpdate state \n     */\n\n\n    setAutoUpdate(status) {\n      this.auto_update = status;\n    }\n    /** \n     * Updates the camera state (interpolated / damped animations) and updates\n     * the renderers' modelview/camera matrix.\n     *\n     * if \"auto_update\" is true, this is called automatically in a pre-draw call.\n     */\n\n\n    update() {\n      var cam = this.cam;\n      var mouse = cam.mouse;\n      mouse.mousedrag();\n      var b_update = false;\n      b_update |= cam.dampedZoom.update();\n      b_update |= cam.dampedPanX.update();\n      b_update |= cam.dampedPanY.update();\n      b_update |= cam.dampedRotX.update();\n      b_update |= cam.dampedRotY.update();\n      b_update |= cam.dampedRotZ.update(); // interpolated actions have lower priority then damped actions\n\n      if (b_update) {\n        cam.timedRot.stop();\n        cam.timedPan.stop();\n        cam.timedzoom.stop();\n      } else {\n        cam.timedRot.update();\n        cam.timedPan.update();\n        cam.timedzoom.update();\n      }\n\n      cam.apply();\n    }\n    /** \n     * Applies the current camera state to the renderers' modelview/camera matrix.\n     * If no argument is given, then the cameras currently set renderer is used.\n     */\n\n\n    apply(renderer) {\n      var cam = this.cam;\n      renderer = renderer || cam.renderer;\n\n      if (renderer) {\n        this.camEYE = this.getPosition(this.camEYE);\n        this.camLAT = this.getCenter(this.camLAT);\n        this.camRUP = this.getUpVector(this.camRUP);\n        if (undefined === renderer._curCamera) renderer.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2], this.camLAT[0], this.camLAT[1], this.camLAT[2], this.camRUP[0], this.camRUP[1], this.camRUP[2]);else renderer._curCamera.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2], this.camLAT[0], this.camLAT[1], this.camLAT[2], this.camRUP[0], this.camRUP[1], this.camRUP[2]);\n      }\n    }\n    /** @param {int[]} the new viewport-def, as [x,y,w,h] */\n\n\n    setViewport(viewport) {\n      this.viewport = viewport.slice();\n    }\n    /** @returns {int[]} the current viewport-def, as [x,y,w,h] */\n\n\n    getViewport() {\n      return this.viewport;\n    } //\n    // mouse state changes\n    //\n\n    /** implemented zoom-cb for mouswheel handler.*/\n\n\n    mouseWheelZoom() {\n      var cam = this;\n      var mouse = cam.mouse;\n      cam.dampedZoom.addForce(mouse.mwheel * cam.scale_zoomwheel);\n    }\n    /** implemented zoom-cb for mousedrag/touch handler.*/\n\n\n    mouseDragZoom() {\n      var cam = this;\n      var mouse = cam.mouse;\n      cam.dampedZoom.addForce(-mouse.dist[2]);\n    }\n    /** implemented pan-cb for mousedrag/touch handler.*/\n\n\n    mouseDragPan() {\n      var cam = this;\n      var mouse = cam.mouse;\n      cam.dampedPanX.addForce(cam.DRAG_CONSTRAINT & cam.AXIS.YAW ? mouse.dist[0] : 0);\n      cam.dampedPanY.addForce(cam.DRAG_CONSTRAINT & cam.AXIS.PITCH ? mouse.dist[1] : 0);\n    }\n    /** implemented rotate-cb for mousedrag/touch handler.*/\n\n\n    mouseDragRotate() {\n      var cam = this;\n      var mouse = cam.mouse;\n      var mx = mouse.curr[0],\n          my = mouse.curr[1];\n      var dx = mouse.dist[0],\n          dy = mouse.dist[1]; // mouse [-1, +1]\n\n      var mxNdc = Math.min(Math.max((mx - cam.viewport[0]) / cam.viewport[2], 0), 1) * 2 - 1;\n      var myNdc = Math.min(Math.max((my - cam.viewport[1]) / cam.viewport[3], 0), 1) * 2 - 1;\n\n      if (cam.DRAG_CONSTRAINT & cam.AXIS.YAW) {\n        cam.dampedRotY.addForce(+dx * (1.0 - myNdc * myNdc));\n      }\n\n      if (cam.DRAG_CONSTRAINT & cam.AXIS.PITCH) {\n        cam.dampedRotX.addForce(-dy * (1.0 - mxNdc * mxNdc));\n      }\n\n      if (cam.DRAG_CONSTRAINT & cam.AXIS.ROLL) {\n        cam.dampedRotZ.addForce(-dx * myNdc);\n        cam.dampedRotZ.addForce(+dy * mxNdc);\n      }\n    } //\n    // damped multipliers\n    //\n\n    /** (private) returns the used zoom -multiplier for damped actions. */\n\n\n    getZoomMult() {\n      return this.state.distance * this.scale_zoom;\n    }\n    /** (private) returns the used pan-multiplier for damped actions. */\n\n\n    getPanMult() {\n      return this.state.distance * this.scale_pan;\n    }\n    /** (private) returns the used rotate-multiplier for damped actions. */\n\n\n    getRotationMult() {\n      return Math.pow(Math.log10(1 + this.state.distance), 0.5) * this.scale_rotation;\n    } //\n    // damped state changes\n    //\n\n    /** Applies a change to the current zoom.  */\n\n\n    zoom(dz) {\n      var cam = this.cam;\n      var distance_tmp = cam.state.distance + dz; // check lower bound\n\n      if (distance_tmp < cam.distance_min) {\n        distance_tmp = cam.distance_min;\n        cam.dampedZoom.stop();\n      } // check upper bound\n\n\n      if (distance_tmp > cam.distance_max) {\n        distance_tmp = cam.distance_max;\n        cam.dampedZoom.stop();\n      }\n\n      cam.state.distance = distance_tmp;\n    }\n    /** Applies a change to the current pan-xValue.  */\n\n\n    panX(dx) {\n      var state = this.cam.state;\n\n      if (dx) {\n        var val = Rotation.applyToVec3(state.rotation, [dx, 0, 0]);\n        Vec3.add(state.center, val, state.center);\n      }\n    }\n    /** Applies a change to the current pan-yValue.  */\n\n\n    panY(dy) {\n      var state = this.cam.state;\n\n      if (dy) {\n        var val = Rotation.applyToVec3(state.rotation, [0, dy, 0]);\n        Vec3.add(state.center, val, state.center);\n      }\n    }\n    /** Applies a change to the current pan-value.  */\n\n\n    pan(dx, dy) {\n      this.cam.panX(dx);\n      this.cam.panY(dx);\n    }\n    /** Applies a change to the current xRotation.  */\n\n\n    rotateX(rx) {\n      this.cam.rotate([1, 0, 0], rx);\n    }\n    /** Applies a change to the current yRotation.  */\n\n\n    rotateY(ry) {\n      this.cam.rotate([0, 1, 0], ry);\n    }\n    /** Applies a change to the current zRotation.  */\n\n\n    rotateZ(rz) {\n      this.cam.rotate([0, 0, 1], rz);\n    }\n    /** Applies a change to the current rotation, using the given axis/angle.  */\n\n\n    rotate(axis, angle) {\n      var state = this.cam.state;\n\n      if (angle) {\n        var new_rotation = Rotation.create({\n          axis: axis,\n          angle: angle\n        });\n        Rotation.applyToRotation(state.rotation, new_rotation, state.rotation);\n      }\n    } // \n    // interpolated states\n    //\n\n    /** Sets the new camera-distance, interpolated (t) between given A and B. */\n\n\n    setInterpolatedDistance(valA, valB, t) {\n      this.cam.state.distance = Scalar.mix(valA, valB, Scalar.smoothstep(t));\n    }\n    /** Sets the new camera-center, interpolated (t) between given A and B. */\n\n\n    setInterpolatedCenter(valA, valB, t) {\n      this.cam.state.center = Vec3.mix(valA, valB, Scalar.smoothstep(t));\n    }\n    /** Sets the new camera-rotation, interpolated (t) between given A and B. */\n\n\n    setInterpolatedRotation(valA, valB, t) {\n      this.cam.state.rotation = Rotation.slerp(valA, valB, t);\n    } //\n    // DISTANCE\n    //\n\n    /** Sets the minimum camera distance. */\n\n\n    setDistanceMin(distance_min) {\n      this.distance_min = Math.max(distance_min, this.distance_min_limit);\n      this.zoom(0); // update, to ensure new minimum\n    }\n    /** Sets the maximum camera distance. */\n\n\n    setDistanceMax(distance_max) {\n      this.distance_max = distance_max;\n      this.zoom(0); // update, to ensure new maximum\n    }\n    /** \n     * Sets the new camera distance.\n     *\n     * @param {double} new distance.\n     * @param {long} animation time in millis.\n     */\n\n\n    setDistance(distance, duration) {\n      this.timedzoom.start(this.state.distance, distance, duration, [this.dampedZoom]);\n    }\n    /** @returns {double} the current camera distance. */\n\n\n    getDistance() {\n      return this.state.distance;\n    } //\n    // CENTER / LOOK AT\n    //\n\n    /** \n     * Sets the new camera center.\n     *\n     * @param {double[]} new center.\n     * @param {long} animation time in millis.\n     */\n\n\n    setCenter(center, duration) {\n      this.timedPan.start(this.state.center, center, duration, [this.dampedPanX, this.dampedPanY]);\n    }\n    /** @returns {double[]} the current camera center. */\n\n\n    getCenter() {\n      return this.state.center;\n    } //\n    // ROTATION\n    //\n\n    /** \n     * Sets the new camera rotation (quaternion).\n     *\n     * @param {double[]} new rotation as quat[q0,q1,q2,q3].\n     * @param {long} animation time in millis.\n     */\n\n\n    setRotation(rotation, duration) {\n      this.timedRot.start(this.state.rotation, rotation, duration, [this.dampedRotX, this.dampedRotY, this.dampedRotZ]);\n    }\n    /** @returns {double[]} the current camera rotation as quat[q0,q1,q2,q3]. */\n\n\n    getRotation() {\n      return this.state.rotation;\n    } //\n    // CAMERA POSITION/EYE\n    //\n\n    /** @returns {double[]} the current camera position, aka. the eye position. */\n\n\n    getPosition(dst) {\n      var cam = this.cam;\n      var state = cam.state;\n      dst = Vec3.assert(dst);\n      Rotation.applyToVec3(state.rotation, cam.LOOK, dst);\n      Vec3.mult(dst, state.distance, dst);\n      Vec3.add(dst, state.center, dst);\n      return dst;\n    } //\n    // CAMERA UP\n    //\n\n    /** @returns {double[]} the current camera up vector. */\n\n\n    getUpVector(dst) {\n      var cam = this.cam;\n      var state = cam.state;\n      dst = Vec3.assert(dst);\n      Rotation.applyToVec3(state.rotation, cam.UP, dst);\n      return dst;\n    } //\n    // STATE (rotation, center, distance)\n    //\n\n    /** @returns {Object} a copy of the camera state {distance,center,rotation} */\n\n\n    getState() {\n      return this.state.copy();\n    }\n    /** \n     * @param {Object} a new camera state {distance,center,rotation}.\n     * @param {long} animation time in millis.\n     */\n\n\n    setState(other, duration) {\n      if (other) {\n        this.setDistance(other.distance, duration);\n        this.setCenter(other.center, duration);\n        this.setRotation(other.rotation, duration);\n      }\n    }\n\n    pushState() {\n      return this.state_pushed = this.getState();\n    }\n\n    popState(duration) {\n      this.setState(this.state_pushed, duration);\n    }\n    /** sets the current state as reset-state. */\n\n\n    pushResetState() {\n      return this.state_reset = this.getState();\n    }\n    /** resets the camera, by applying the reset-state. */\n\n\n    reset(duration) {\n      this.setState(this.state_reset, duration);\n    }\n    /** sets the rotation scale/speed. */\n\n\n    setRotationScale(scale_rotation) {\n      this.scale_rotation = scale_rotation;\n    }\n    /** sets the pan scale/speed. */\n\n\n    setPanScale(scale_pan) {\n      this.scale_pan = scale_pan;\n    }\n    /** sets the zoom scale/speed. */\n\n\n    setZoomScale(scale_zoom) {\n      this.scale_zoom = scale_zoom;\n    }\n    /** sets the wheel scale/speed. */\n\n\n    setWheelScale(wheelScale) {\n      this.scale_zoomwheel = wheelScale;\n    }\n    /** @returns the rotation scale/speed. */\n\n\n    getRotationScale() {\n      return this.scale_rotation;\n    }\n    /** @returns the pan scale/speed. */\n\n\n    getPanScale() {\n      return this.scale_pan;\n    }\n    /** @returns the zoom scale/speed. */\n\n\n    getZoomScale() {\n      return this.scale_zoom;\n    }\n    /** @returns the wheel scale/speed. */\n\n\n    getWheelScale() {\n      return this.scale_zoomwheel;\n    }\n    /** sets the default damping scale/speed. */\n\n\n    setDamping(damping) {\n      this.dampedZoom.damping = damping;\n      this.dampedPanX.damping = damping;\n      this.dampedPanY.damping = damping;\n      this.dampedRotX.damping = damping;\n      this.dampedRotY.damping = damping;\n      this.dampedRotZ.damping = damping;\n    }\n    /** sets the default interpolation time in millis. */\n\n\n    setDefaultInterpolationTime(duration) {\n      this.timedRot.default_duration = duration;\n      this.timedPan.default_duration = duration;\n      this.timedzoom.default_duration = duration;\n    }\n    /** \n     * sets the rotation constraint for each axis separately.\n     *\n     * @param {boolean} yaw constraint\n     * @param {boolean} pitch constraint\n     * @param {boolean} roll constraint\n     */\n\n\n    setRotationConstraint(yaw, pitch, roll) {\n      var cam = this.cam;\n      cam.FIXED_CONSTRAINT = 0;\n      cam.FIXED_CONSTRAINT |= yaw ? cam.AXIS.YAW : 0;\n      cam.FIXED_CONSTRAINT |= pitch ? cam.AXIS.PITCH : 0;\n      cam.FIXED_CONSTRAINT |= roll ? cam.AXIS.ROLL : 0;\n    }\n    /**\n     * \n     * begin screen-aligned 2D-drawing.\n     * \n     * <pre>\n     * beginHUD()\n     *   disabled depth test\n     *   ortho\n     *   ... your code is executed here ...\n     * endHUD()\n     * </pre>\n     * \n     */\n\n\n    beginHUD(renderer, w, h) {\n      var cam = this.cam;\n      renderer = renderer || cam.renderer;\n      if (!renderer) return;\n      this.pushed_rendererState = renderer.push();\n      var gl = renderer.drawingContext;\n      var w = w !== undefined ? w : renderer.width;\n      var h = h !== undefined ? h : renderer.height;\n      var d = Number.MAX_VALUE;\n      gl.flush(); // gl.finish();\n      // 1) disable DEPTH_TEST\n\n      gl.disable(gl.DEPTH_TEST); // 2) push modelview/projection\n      //    p5 is not creating a push/pop stack\n\n      this.pushed_uMVMatrix = renderer.uMVMatrix.copy();\n      this.pushed_uPMatrix = renderer.uPMatrix.copy(); // 3) set new modelview (identity)\n\n      renderer.resetMatrix(); // 4) set new projection (ortho)\n\n      renderer._curCamera.ortho(0, w, -h, 0, -d, +d); // renderer.ortho();\n      // renderer.translate(-w/2, -h/2);\n\n    }\n    /**\n     * \n     * end screen-aligned 2D-drawing.\n     * \n     */\n\n\n    endHUD(renderer) {\n      var cam = this.cam;\n      renderer = renderer || cam.renderer;\n      if (!renderer) return;\n      var gl = renderer.drawingContext;\n      gl.flush(); // gl.finish();\n      // 2) restore modelview/projection\n\n      renderer.uMVMatrix.set(this.pushed_uMVMatrix);\n      renderer.uPMatrix.set(this.pushed_uPMatrix); // 1) enable DEPTH_TEST\n\n      gl.enable(gl.DEPTH_TEST);\n      renderer.pop(this.pushed_rendererState);\n    }\n\n  }\n  /**\n   * Damped callback, that accepts the resulting damped/smooth value.\n   *\n   * @callback dampedCallback\n   * @param {double} value - the damped/smoothed value\n   *\n   */\n\n  /**\n   *\n   * DampedAction, for smoothly changing a value to zero.\n   *\n   * @param {dampedCallback} cb - callback that accepts the damped value as argument.\n   */\n\n\n  class DampedAction {\n    /**  @constructor */\n    constructor(cb) {\n      this.value = 0.0;\n      this.damping = 0.85;\n      this.action = cb;\n    }\n    /** adds a value to the current value beeing damped. \n     * @param {double} force - the value beeing added.\n     */\n\n\n    addForce(force) {\n      this.value += force;\n    }\n    /** updates the damping and calls {@link damped-callback}. */\n\n\n    update() {\n      var active = this.value * this.value > 0.000001;\n\n      if (active) {\n        this.action(this.value);\n        this.value *= this.damping;\n      } else {\n        this.stop();\n      }\n\n      return active;\n    }\n    /** stops the damping. */\n\n\n    stop() {\n      this.value = 0.0;\n    }\n\n  }\n  /**\n   * Interpolation callback, that implements any form of interpolation between\n   * two values A and B and the interpolationparameter t.\n   * <pre>\n   *   linear: A * (1-t) + B * t\n   *   smooth, etc...\n   * </pre>\n   * @callback interpolationCallback\n   * @param {Object} A - First Value\n   * @param {Object} B - Second Value\n   * @param {double} t - interpolation parameter [0, 1]\n   *\n   */\n\n  /**\n   *\n   * Interpolation, for smoothly changing a value by interpolating it over time.\n   *\n   * @param {interpolationCallback} cb - callback for interpolating between two values.\n   */\n\n\n  class Interpolation {\n    /**  @constructor */\n    constructor(cb) {\n      this.default_duration = 300;\n      this.action = cb;\n    }\n    /** starts the interpolation.\n     *  If the given interpolation-duration is 0, then\n     * {@link interpolation-callback} is called immediately.\n     */\n\n\n    start(valA, valB, duration, actions) {\n      for (var x in actions) {\n        actions[x].stop();\n      }\n\n      this.valA = valA;\n      this.valB = valB;\n      this.duration = duration === undefined ? this.default_duration : duration;\n      this.timer = new Date().getTime();\n      this.active = this.duration > 0;\n\n      if (!this.active) {\n        this.interpolate(1);\n      }\n    }\n    /** updates the interpolation and calls {@link interpolation-callback}.*/\n\n\n    update() {\n      if (this.active) {\n        var t = (new Date().getTime() - this.timer) / this.duration;\n\n        if (t > 0.995) {\n          this.interpolate(1);\n          this.stop();\n        } else {\n          this.interpolate(t);\n        }\n      }\n    }\n\n    interpolate(t) {\n      this.action(this.valA, this.valB, t);\n    }\n    /** stops the interpolation. */\n\n\n    stop() {\n      this.active = false;\n    }\n\n  } ////////////////////////////////////////////////////////////////////////////////\n  //\n  // ROTATION (Quaternion)\n  //\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Rotation as Quaternion [q0, q1, q2, q3]\n   *\n   * Note: Only functions that were required for the EasyCam to work are implemented.\n   * \n   * @namespace\n   */\n\n\n  var Rotation = {\n    assert: function (dst) {\n      return dst === undefined || dst.constructor !== Array ? [1, 0, 0, 0] : dst;\n    },\n\n    /** @returns {Number[]} an identity rotation [1,0,0,0] */\n    identity: function () {\n      return [1, 0, 0, 0];\n    },\n\n    /** \n     * Applies the rotation to a vector and returns dst or a new vector.\n     *\n     * @param {Number[]} rot - Rotation (Quaternion)\n     * @param {Number[]} vec - vector to be rotated by rot\n     * @param {Number[]} dst - resulting vector\n     * @returns {Number[]} dst- resulting vector\n     */\n    applyToVec3: function (rot, vec, dst) {\n      var [x, y, z] = vec;\n      var [q0, q1, q2, q3] = rot;\n      var s = q1 * x + q2 * y + q3 * z;\n      dst = Vec3.assert(dst);\n      dst[0] = 2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x;\n      dst[1] = 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y;\n      dst[2] = 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z;\n      return dst;\n    },\n\n    /** \n     * Applies the rotation to another rotation and returns dst or a new rotation.\n     *\n     * @param {Number[]} rotA - RotationA (Quaternion)\n     * @param {Number[]} rotB - RotationB (Quaternion)\n     * @param {Number[]} dst - resulting rotation\n     * @returns {Number[]} dst - resulting rotation\n     */\n    applyToRotation(rotA, rotB, dst) {\n      var [a0, a1, a2, a3] = rotA;\n      var [b0, b1, b2, b3] = rotB;\n      dst = Rotation.assert(dst);\n      dst[0] = b0 * a0 - (b1 * a1 + b2 * a2 + b3 * a3);\n      dst[1] = b1 * a0 + b0 * a1 + (b2 * a3 - b3 * a2);\n      dst[2] = b2 * a0 + b0 * a2 + (b3 * a1 - b1 * a3);\n      dst[3] = b3 * a0 + b0 * a3 + (b1 * a2 - b2 * a1);\n      return dst;\n    },\n\n    /** \n     * Interpolates a rotation.\n     *\n     * @param {Number[]} rotA - RotationA (Quaternion)\n     * @param {Number[]} rotB - RotationB (Quaternion)\n     * @param {Number  } t - interpolation parameter\n     * @param {Number[]} dst - resulting rotation\n     * @returns {Number[]} dst - resulting rotation\n     */\n    slerp: function (rotA, rotB, t, dst) {\n      var [a0, a1, a2, a3] = rotA;\n      var [b0, b1, b2, b3] = rotB;\n      var cosTheta = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n\n      if (cosTheta < 0) {\n        b0 = -b0;\n        b1 = -b1;\n        b2 = -b2;\n        b3 = -b3;\n        cosTheta = -cosTheta;\n      }\n\n      var theta = Math.acos(cosTheta);\n      var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n      var w1, w2;\n\n      if (sinTheta > 0.001) {\n        w1 = Math.sin((1.0 - t) * theta) / sinTheta;\n        w2 = Math.sin(t * theta) / sinTheta;\n      } else {\n        w1 = 1.0 - t;\n        w2 = t;\n      }\n\n      dst = Rotation.assert(dst);\n      dst[0] = w1 * a0 + w2 * b0;\n      dst[1] = w1 * a1 + w2 * b1;\n      dst[2] = w1 * a2 + w2 * b2;\n      dst[3] = w1 * a3 + w2 * b3;\n      return Rotation.create({\n        rotation: dst,\n        normalize: true\n      }, dst);\n    },\n\n    /** \n     * Creates/Initiates a new Rotation\n     *\n     * <pre>\n     *\n     *    1) Axis,Angle:\n     *       {\n     *         axis : [x, y, z],\n     *         angle: double\n     *       }\n     *      \n     *    2) Another Rotation:\n     *       {\n     *         rotation : [q0, q1, q2, q3],\n     *         normalize: boolean\n     *       }\n     *      \n     *    3) 3 euler angles, XYZ-order:\n     *       {\n     *         angles_xyz : [rX, rY, rZ]\n     *       }\n     *   \n     * </pre>\n     *\n     *\n     * @param {Object} def - Definition, for creating the new Rotation\n     * @param {Number[]} dst - resulting rotation\n     * @returns {Number[]} dst - resulting rotation\n     */\n    create: function (def, dst) {\n      dst = Rotation.assert(dst); // 1) from axis and angle\n\n      if (def.axis) {\n        var axis = def.axis;\n        var angle = def.angle;\n        var norm = Vec3.mag(axis);\n        if (norm == 0.0) return; // vector is of zero length\n\n        var halfAngle = -0.5 * angle;\n        var coeff = Math.sin(halfAngle) / norm;\n        dst[0] = Math.cos(halfAngle);\n        dst[1] = coeff * axis[0];\n        dst[2] = coeff * axis[1];\n        dst[3] = coeff * axis[2];\n        return dst;\n      } // 2) from another rotation\n\n\n      if (def.rotation) {\n        dst[0] = def.rotation[0];\n        dst[1] = def.rotation[1];\n        dst[2] = def.rotation[2];\n        dst[3] = def.rotation[3];\n\n        if (def.normalize) {\n          var inv = 1.0 / Math.sqrt(dst[0] * dst[0] + dst[1] * dst[1] + dst[2] * dst[2] + dst[3] * dst[3]);\n          dst[0] *= inv;\n          dst[1] *= inv;\n          dst[2] *= inv;\n          dst[3] *= inv;\n        }\n\n        return dst;\n      } // 3) from 3 euler angles, order XYZ\n\n\n      if (def.angles_xyz) {\n        var ax = -0.5 * def.angles_xyz[0];\n        var ay = -0.5 * def.angles_xyz[1];\n        var az = -0.5 * def.angles_xyz[2];\n        var rotX = [Math.cos(ax), Math.sin(ax), 0, 0];\n        var rotY = [Math.cos(ay), 0, Math.sin(ay), 0];\n        var rotZ = [Math.cos(az), 0, 0, Math.sin(az)];\n        Rotation.applyToRotation(rotY, rotZ, dst);\n        Rotation.applyToRotation(rotX, dst, dst);\n        return dst;\n      }\n    } //\n    // ... to be continued ...\n    //\n\n  }; ////////////////////////////////////////////////////////////////////////////////\n  //\n  // SCALAR\n  //\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Scalar as a simple number.\n   *\n   * Note: Only functions that were required for the EasyCam to work are implemented.\n   *\n   * @namespace\n   */\n\n  var Scalar = {\n    /**\n     * Linear interpolation between A and B using t[0,1]\n     */\n    mix: function (a, b, t) {\n      return a * (1 - t) + b * t;\n    },\n\n    /**\n     * modifying t as a function of smoothstep(0,1,t);\n     */\n    smoothstep: function (x) {\n      return x * x * (3 - 2 * x);\n    },\n\n    /**\n     * modifying t as a function of smootherstep(0,1,t);\n     */\n    smootherstep: function (t) {\n      return x * x * x * (x * (x * 6 - 15) + 10);\n    }\n  }; ////////////////////////////////////////////////////////////////////////////////\n  //\n  // VEC3\n  //\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * Vec3 as a 3D vector (Array)\n   *\n   * @namespace\n   */\n\n  var Vec3 = {\n    assert: function (dst) {\n      return dst === undefined || dst.constructor !== Array ? [0, 0, 0] : dst;\n    },\n    isScalar: function (arg) {\n      // TODO: do some profiling to figure out what fails\n      return arg !== undefined && arg.constructor !== Array; // return typeof(arg) === 'number';\n    },\n\n    /** addition: <pre> dst = a + b </pre>  */\n    add: function (a, b, dst) {\n      dst = this.assert(dst);\n\n      if (this.isScalar(b)) {\n        dst[0] = a[0] + b;\n        dst[1] = a[1] + b;\n        dst[2] = a[2] + b;\n      } else {\n        dst[0] = a[0] + b[0];\n        dst[1] = a[1] + b[1];\n        dst[2] = a[2] + b[2];\n      }\n\n      return dst;\n    },\n\n    /** componentwise multiplication: <pre> dst = a * b </pre>  */\n    mult: function (a, b, dst) {\n      dst = this.assert(dst);\n\n      if (this.isScalar(b)) {\n        dst[0] = a[0] * b;\n        dst[1] = a[1] * b;\n        dst[2] = a[2] * b;\n      } else {\n        dst[0] = a[0] * b[0];\n        dst[1] = a[1] * b[1];\n        dst[2] = a[2] * b[2];\n      }\n\n      return dst;\n    },\n\n    /** squared length  */\n    magSq: function (a) {\n      return a[0] * a[0] + a[1] * a[1] + a[2] * a[2];\n    },\n\n    /** length  */\n    mag: function (a) {\n      return Math.sqrt(a[0] * a[0] + a[1] * a[1] + a[2] * a[2]);\n    },\n\n    /** dot-product  */\n    dot: function (a, b) {\n      return a[0] * b[0] + a[1] * b[1] + a[2] * b[2];\n    },\n\n    /** cross-product  */\n    cross: function (a, b, dst) {\n      dst = this.assert(dst);\n      dst[0] = a[1] * b[2] - a[2] * b[1];\n      dst[1] = a[2] * b[0] - a[0] * b[2];\n      dst[2] = a[0] * b[1] - a[1] * b[0];\n      return dst;\n    },\n\n    /** angle  */\n    angle: function (v1, v2) {\n      var normProduct = this.mag(v1) * this.mag(v2);\n\n      if (normProduct === 0.0) {\n        return 0.0; // at least one vector is of zero length\n      }\n\n      var dot = this.dot(v1, v2);\n      var threshold = normProduct * 0.9999;\n\n      if (dot < -threshold || dot > threshold) {\n        // the vectors are almost aligned, compute using the sine\n        var v3 = this.cross(v1, v2);\n\n        if (dot >= 0) {\n          return Math.asin(this.mag(v3) / normProduct);\n        } else {\n          return Math.PI - Math.asin(this.mag(v3) / normProduct);\n        }\n      } // the vectors are sufficiently separated to use the cosine\n\n\n      return Math.acos(dot / normProduct);\n    },\n\n    /** linear interpolation: <pre> dst = a * (1 - t) + b * t </pre> */\n    mix(a, b, t, dst) {\n      dst = this.assert(dst);\n      dst[0] = Scalar.mix(a[0], b[0], t);\n      dst[1] = Scalar.mix(a[1], b[1], t);\n      dst[2] = Scalar.mix(a[2], b[2], t);\n      return dst;\n    } //\n    // ... to be continued ...\n    //\n\n\n  }; ////////////////////////////////////////////////////////////////////////////////\n  //\n  // public objects\n  //\n  ////////////////////////////////////////////////////////////////////////////////\n\n  /**\n   * @static\n   */\n\n  EasyCam.INFO = INFO; // make static\n\n  Object.freeze(INFO); // and constant\n\n  ext = ext !== undefined ? ext : {};\n  /**\n   * @memberof Dw\n   */\n\n  ext.EasyCam = EasyCam;\n  /**\n   * @memberof Dw\n   */\n\n  ext.DampedAction = DampedAction;\n  /**\n   * @memberof Dw\n   */\n\n  ext.Interpolation = Interpolation;\n  /**\n   * @memberof Dw\n   */\n\n  ext.Rotation = Rotation;\n  /**\n   * @memberof Dw\n   */\n\n  ext.Vec3 = Vec3;\n  /**\n   * @memberof Dw\n   */\n\n  ext.Scalar = Scalar;\n  return ext;\n}(Dw);\n/**\n * @submodule Camera\n * @for p5\n */\n\n\nif (p5) {\n  /**\n   * p5.EasyCam creator function. \n   * Arguments are optional, and equal to the default EasyCam constructor.\n   * @return {EasyCam} a new EasyCam\n   */\n  p5.prototype.createEasyCam = function ()\n  /* p5.RendererGL, {state} */\n  {\n    var renderer = this._renderer;\n    var args = arguments[0];\n\n    if (arguments[0] instanceof p5.RendererGL) {\n      renderer = arguments[0];\n      args = arguments[1]; // could still be undefined, which is fine\n    }\n\n    return new Dw.EasyCam(renderer, args);\n  };\n}","map":{"version":3,"sources":["/Users/aluan/Documents/GitHub/GeoPunk/node_modules/p5.easycam.js"],"names":["Dw","ext","INFO","LIBRARY","VERSION","AUTHOR","SOURCE","toString","EasyCam","constructor","renderer","args","p5","RendererGL","console","log","bounds","elt","getBoundingClientRect","distance","undefined","center","rotation","Rotation","identity","viewport","width","height","offset","x","window","scrollX","y","scrollY","setCanvas","cam","LOOK","UP","AXIS","YAW","PITCH","ROLL","ALL","SHIFT_CONSTRAINT","FIXED_CONSTRAINT","DRAG_CONSTRAINT","scale_rotation","scale_pan","scale_zoom","scale_zoomwheel","distance_min_limit","distance_min","distance_max","Number","MAX_VALUE","state","slice","copy","dst","state_reset","state_pushed","addEventListener","e","p","mouse","curr","prev","dist","mwheel","isPressed","istouchdown","ismousedown","BUTTON","LMB","MMB","RMB","button","mouseDragLeft","mouseDragRotate","bind","mouseDragCenter","mouseDragPan","mouseDragRight","mouseDragZoom","mouseWheelAction","mouseWheelZoom","touchmoveSingle","touchmoveMulti","insideViewport","x0","x1","y0","y1","solveConstraint","dx","dy","shiftKey","Math","abs","updateInput","z","pd","P5","pixelDensity","mousedown","event","offX","offY","mousedrag","mouseX","mouseY","mouseup","dblclick","reset","wheel","deltaY","evaluateTouches","touches","avg_x","avg_y","avg_d","i","count","length","clientX","clientY","sqrt","touchstart","preventDefault","stopPropagation","dbltap","touchmove","tapcount","touchend","setTimeout","keydown","keyCode","keyup","attachMouseListeners","auto_update","registerMethod","update","dampedZoom","DampedAction","d","zoom","getZoomMult","dampedPanX","panX","getPanMult","dampedPanY","panY","dampedRotX","rotateX","getRotationMult","dampedRotY","rotateY","dampedRotZ","rotateZ","timedRot","Interpolation","setInterpolatedRotation","timedPan","setInterpolatedCenter","timedzoom","setInterpolatedDistance","_pInst","graphics","getCanvas","attachListener","el","ev","fx","op","detachListener","removeEventListener","passive","removeMouseListeners","dispose","getAutoUpdate","setAutoUpdate","status","b_update","stop","apply","camEYE","getPosition","camLAT","getCenter","camRUP","getUpVector","_curCamera","camera","setViewport","getViewport","addForce","mx","my","mxNdc","min","max","myNdc","pow","log10","dz","distance_tmp","val","applyToVec3","Vec3","add","pan","rx","rotate","ry","rz","axis","angle","new_rotation","create","applyToRotation","valA","valB","t","Scalar","mix","smoothstep","slerp","setDistanceMin","setDistanceMax","setDistance","duration","start","getDistance","setCenter","setRotation","getRotation","assert","mult","getState","setState","other","pushState","popState","pushResetState","setRotationScale","setPanScale","setZoomScale","setWheelScale","wheelScale","getRotationScale","getPanScale","getZoomScale","getWheelScale","setDamping","damping","setDefaultInterpolationTime","default_duration","setRotationConstraint","yaw","pitch","roll","beginHUD","w","h","pushed_rendererState","push","gl","drawingContext","flush","disable","DEPTH_TEST","pushed_uMVMatrix","uMVMatrix","pushed_uPMatrix","uPMatrix","resetMatrix","ortho","endHUD","set","enable","pop","cb","value","action","force","active","actions","timer","Date","getTime","interpolate","Array","rot","vec","q0","q1","q2","q3","s","rotA","rotB","a0","a1","a2","a3","b0","b1","b2","b3","cosTheta","theta","acos","sinTheta","w1","w2","sin","normalize","def","norm","mag","halfAngle","coeff","cos","inv","angles_xyz","ax","ay","az","rotX","rotY","rotZ","a","b","smootherstep","isScalar","arg","magSq","dot","cross","v1","v2","normProduct","threshold","v3","asin","PI","Object","freeze","prototype","createEasyCam","_renderer","arguments"],"mappings":"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","sourcesContent":["/*\n * \n * The p5.EasyCam library - Easy 3D CameraControl for p5.js and WEBGL.\n *\n *   Copyright Â© 2017-2021 by p5.EasyCam authors\n *\n *   Source: https://github.com/freshfork/p5.EasyCam\n *\n *   MIT License: https://opensource.org/licenses/MIT\n * \n * \n * explanatory notes:\n * \n * p5.EasyCam is a derivative of the original PeasyCam Library by Jonathan Feinberg \n * and combines new useful features with the great look and feel of its parent.\n * \n */\n\n \n \n'use strict';\n\n\n\n/** @namespace  */\nvar Dw = (function(ext) {\n  \n\n  \n/**\n * EasyCam Library Info\n */\nconst INFO = \n{\n  /** name    */ LIBRARY : \"p5.EasyCam\",\n  /** version */ VERSION : \"1.2.0\",\n  /** author  */ AUTHOR  : \"p5.EasyCam authors\",\n  /** source  */ SOURCE  : \"https://github.com/freshfork/p5.EasyCam\",\n  \n  toString : function(){\n    return this.LIBRARY+\" v\"+this.VERSION+\" by \"+this.AUTHOR+\" (\"+this.SOURCE+\")\";\n  },\n  \n};\n\n\n\n/**\n * EasyCam\n *\n * <pre>\n *\n *   new Dw.EasyCam(p5.RendererGL, {\n *     distance : z,                 // scalar\n *     center   : [x, y, z],         // vector\n *     rotation : [q0, q1, q2, q3],  // quaternion\n *     viewport : [x, y, w, h],      // array\n *   }\n *\n * </pre>\n *\n * @param {p5.RendererGL} renderer - p5 WEBGL renderer\n * @param {Object}        args     - {distance, center, rotation, viewport}\n *\n */\nclass EasyCam {\n\n  /**\n   * @constructor\n   */\n  constructor(renderer, args) {\n    \n\n    // WEBGL renderer required\n    if(!(renderer instanceof p5.RendererGL)){\n      console.log(\"renderer needs to be an instance of p5.RendererGL\");\n      return;\n    }\n    var bounds = renderer.elt.getBoundingClientRect();\n    \n    // define default args\n    args = args || {};\n    if(args.distance === undefined) args.distance  = 500;\n    if(args.center   === undefined) args.center    = [0, 0, 0];\n    if(args.rotation === undefined) args.rotation  = Rotation.identity();\n    if(args.viewport === undefined) args.viewport  = [0, 0, renderer.width, renderer.height];\n    if(args.offset   === undefined) args.offset    = [bounds.x + window.scrollX, bounds.y + window.scrollY];\n\n    // library info\n    this.INFO = INFO;\n\n    // set renderer, graphics, p5\n    // this.renderer;\n    // this.graphics;\n    // this.P5\n    this.setCanvas(renderer);\n\n    // self reference\n    var cam = this;\n    this.cam = cam;\n    \n    // some constants\n    this.LOOK = [0, 0, 1];\n    this.UP   = [0, 1, 0];\n\n    // principal axes flags\n    this.AXIS = new function() {\n      this.YAW   = 0x01;\n      this.PITCH = 0x02;\n      this.ROLL  = 0x04;\n      this.ALL   = this.YAW | this.PITCH | this.ROLL;\n    };\n  \n    // mouse action constraints\n    this.SHIFT_CONSTRAINT = 0; // applied when pressing the shift key\n    this.FIXED_CONSTRAINT = 0; // applied, when set by user and SHIFT_CONSTRAINT is 0\n    this.DRAG_CONSTRAINT  = 0; // depending on SHIFT_CONSTRAINT and FIXED_CONSTRAINT, default is ALL\n    \n    // mouse action speed\n    this.scale_rotation  = 0.001;\n    this.scale_pan       = 0.0002;\n    this.scale_zoom      = 0.001;\n    this.scale_zoomwheel = 20.0;\n    \n    // zoom limits\n    this.distance_min_limit = 0.01;\n    this.distance_min       = 1.0;\n    this.distance_max       = Number.MAX_VALUE;\n    \n    // main state\n    this.state = {\n      distance : args.distance,         // scalar\n      center   : args.center.slice(),   // vec3\n      rotation : args.rotation.slice(), // quaternion\n      \n      copy : function(dst){\n        dst = dst || {};\n        dst.distance = this.distance;      \n        dst.center   = this.center.slice(); \n        dst.rotation = this.rotation.slice();\n        return dst;\n      },\n    };\n\n    // backup-state at start\n    this.state_reset  = this.state.copy();\n    // backup-state, probably not required\n    this.state_pushed = this.state.copy();\n    \n    // viewport for the mouse-pointer [x,y,w,h]\n    this.viewport = args.viewport.slice();\n    \n    // offset of the canvas in the container\n    this.offset = args.offset.slice();\n    \n    // add a handler for window resizing\n    window.addEventListener('resize', function (e){\n      let p = renderer.elt.getBoundingClientRect();\n      cam.offset = [p.x + window.scrollX, p.y + window.scrollY];\n    });\n    \n    // mouse/touch/key action handler\n    this.mouse = {\n      \n      cam : cam,\n      \n      curr   : [0,0,0],\n      prev   : [0,0,0],\n      dist   : [0,0,0],\n      mwheel : 0,\n      \n      isPressed   : false, // true if (istouchdown || ismousedown)\n      istouchdown : false, // true, if input came from a touch\n      ismousedown : false, // true, if input came from a mouse\n      \n      BUTTON : {  LMB:0x01, MMB:0x02, RMB:0x04  },\n      \n      button : 0,\n     \n      mouseDragLeft   : cam.mouseDragRotate.bind(cam),\n      mouseDragCenter : cam.mouseDragPan   .bind(cam),\n      mouseDragRight  : cam.mouseDragZoom  .bind(cam),\n      mouseWheelAction: cam.mouseWheelZoom .bind(cam),\n      \n      touchmoveSingle : cam.mouseDragRotate.bind(cam),\n      touchmoveMulti  : function(){\n                          cam.mouseDragPan();\n                          cam.mouseDragZoom();\n                        },\n     \n      \n      insideViewport : function(x, y){\n        var x0 = cam.viewport[0], x1 = x0 + cam.viewport[2];\n        var y0 = cam.viewport[1], y1 = y0 + cam.viewport[3];\n        return (x > x0) && (x < x1) && (y > y0) && (y < y1);\n      },\n      \n      solveConstraint : function(){\n        var dx = this.dist[0];\n        var dy = this.dist[1];\n        \n        // YAW, PITCH\n        if (this.shiftKey && !cam.SHIFT_CONSTRAINT && Math.abs(dx - dy) > 1) {\n          cam.SHIFT_CONSTRAINT = Math.abs(dx) > Math.abs(dy) ? cam.AXIS.YAW : cam.AXIS.PITCH;\n        }\n        \n        // define constraint by increasing priority\n        cam.DRAG_CONSTRAINT = cam.AXIS.ALL;\n        if(cam.FIXED_CONSTRAINT) cam.DRAG_CONSTRAINT = cam.FIXED_CONSTRAINT;\n        if(cam.SHIFT_CONSTRAINT) cam.DRAG_CONSTRAINT = cam.SHIFT_CONSTRAINT;\n      },\n\n      updateInput : function(x,y,z){\n        var mouse = cam.mouse;\n        var pd = cam.P5.pixelDensity();\n        \n        mouse.prev[0] = mouse.curr[0];\n        mouse.prev[1] = mouse.curr[1];\n        mouse.prev[2] = mouse.curr[2];\n        \n        mouse.curr[0] = x;\n        mouse.curr[1] = y;\n        mouse.curr[2] = z;\n        \n        mouse.dist[0] = -(mouse.curr[0] - mouse.prev[0]) / pd;\n        mouse.dist[1] = -(mouse.curr[1] - mouse.prev[1]) / pd;\n        mouse.dist[2] = -(mouse.curr[2] - mouse.prev[2]) / pd;\n      },\n\n      \n      \n      //////////////////////////////////////////////////////////////////////////\n      // mouseinput\n      //////////////////////////////////////////////////////////////////////////\n\n      mousedown : function(event){\n        var mouse = cam.mouse;\n        // Account for canvas shift:\n        var offX = cam.offset[0] - window.scrollX,\n            offY = cam.offset[1] - window.scrollY;\n        \n        if(event.button === 0) mouse.button |= mouse.BUTTON.LMB;\n        if(event.button === 1) mouse.button |= mouse.BUTTON.MMB;\n        if(event.button === 2) mouse.button |= mouse.BUTTON.RMB;\n        \n        if(mouse.insideViewport(event.x - offX, event.y - offY)){\n          mouse.updateInput(event.x - offX, event.y - offY, event.y - offY);\n          mouse.ismousedown = mouse.button > 0;\n          mouse.isPressed   = mouse.ismousedown;\n          cam.SHIFT_CONSTRAINT = 0;\n        } \n      },\n      \n      mousedrag : function(){\n        var pd = cam.P5.pixelDensity();\n        \n        var mouse = cam.mouse;\n        if(mouse.ismousedown){\n          \n          var x = cam.P5.mouseX;\n          var y = cam.P5.mouseY;\n          var z = y;\n          \n          mouse.updateInput(x, y, z);\n          mouse.solveConstraint();\n          \n          var LMB = mouse.button & mouse.BUTTON.LMB;\n          var MMB = mouse.button & mouse.BUTTON.MMB;\n          var RMB = mouse.button & mouse.BUTTON.RMB;\n          \n          if(LMB && mouse.mouseDragLeft  ) mouse.mouseDragLeft();\n          if(MMB && mouse.mouseDragCenter) mouse.mouseDragCenter();\n          if(RMB && mouse.mouseDragRight ) mouse.mouseDragRight();\n        }\n      },\n      \n      mouseup : function(event){\n        var mouse = cam.mouse;\n        \n        if(event.button === 0) mouse.button &= ~mouse.BUTTON.LMB;\n        if(event.button === 1) mouse.button &= ~mouse.BUTTON.MMB;\n        if(event.button === 2) mouse.button &= ~mouse.BUTTON.RMB;\n        \n        mouse.ismousedown = mouse.button > 0;\n        mouse.isPressed = (mouse.istouchdown || mouse.ismousedown);\n        cam.SHIFT_CONSTRAINT = 0;\n      },\n      \n      dblclick : function(event){\n        // Account for canvas shift:\n        var offX = cam.offset[0] - window.scrollX,\n            offY = cam.offset[1] - window.scrollY;\n\n        if(cam.mouse.insideViewport(event.x - offX, event.y - offY)){\n          cam.reset();\n        }\n      },\n      \n      wheel : function(event){\n        var x = event.x;\n        var y = event.y;\n        var mouse = cam.mouse;\n        if(mouse.insideViewport(x, y)){\n          mouse.mwheel = event.deltaY * 0.01;\n          if(mouse.mouseWheelAction) mouse.mouseWheelAction();\n        }\n      },\n      \n      \n      \n      //////////////////////////////////////////////////////////////////////////\n      // touchinput\n      //////////////////////////////////////////////////////////////////////////\n      \n      evaluateTouches : function(event){\n        var touches = event.touches;\n        var avg_x = 0.0;\n        var avg_y = 0.0;\n        var avg_d = 0.0;\n        var i, dx, dy, count = touches.length;\n        // Account for canvas shift:\n        var offX = cam.offset[0] - window.scrollX,\n            offY = cam.offset[1] - window.scrollY;\n\n        // center, averaged touch position\n        for(i = 0; i < count; i++){\n          avg_x += touches[i].clientX - offX;\n          avg_y += touches[i].clientY - offY;\n        }\n        avg_x /= count;\n        avg_y /= count;\n        \n        // offset, mean distance to center\n        for(i = 0; i < count; i++){\n          dx = avg_x - (touches[i].clientX - offX);\n          dy = avg_y - (touches[i].clientY - offY);\n          avg_d += Math.sqrt(dx*dx + dy*dy);\n        }\n        avg_d /= count;\n        \n        cam.mouse.updateInput(avg_x, avg_y, -avg_d);\n      },\n      \n\n      touchstart : function(event){\n        event.preventDefault();\n\t\t    event.stopPropagation();\n        \n        var mouse = cam.mouse;\n        \n        mouse.evaluateTouches(event);\n        mouse.istouchdown = mouse.insideViewport(mouse.curr[0], mouse.curr[1]);\n        mouse.isPressed = (cam.mouse.istouchdown || cam.mouse.ismousedown);\n    \n        mouse.dbltap(event);\n      },\n      \n      touchmove : function(event){\n        event.preventDefault();\n\t\t    event.stopPropagation();\n        \n        var mouse = cam.mouse;\n        \n        if(mouse.istouchdown){\n          \n          mouse.evaluateTouches(event);  \n          mouse.solveConstraint();\n\n          if(event.touches.length === 1){\n            mouse.touchmoveSingle();\n          } else {\n            mouse.touchmoveMulti();\n            mouse.tapcount = 0;\n          }\n        }\n      },\n      \n      touchend : function(event){\n        event.preventDefault();\n\t\t    event.stopPropagation();\n        \n        var mouse = cam.mouse;\n\n        mouse.istouchdown = false,\n        mouse.isPressed = (mouse.istouchdown || mouse.ismousedown);\n        cam.SHIFT_CONSTRAINT = 0;\n        \n        if(mouse.tapcount >= 2){\n          if(mouse.insideViewport(mouse.curr[0], mouse.curr[1])){\n            cam.reset();\n          }\n          mouse.tapcount = 0;\n        }\n      },\n\n      \n      tapcount : 0,\n       \n      dbltap : function(event) {\n        if(cam.mouse.tapcount++ == 0) {\n          setTimeout( function() { \n            cam.mouse.tapcount = 0; \n          }, 350 );\n        } \n      },\n      \n      \n      \n      //////////////////////////////////////////////////////////////////////////\n      // keyingput\n      //////////////////////////////////////////////////////////////////////////\n      \n      // key-event for shift constraints\n      shiftKey : false,\n   \n      keydown : function(event){\n        var mouse = cam.mouse;\n        if(!mouse.shiftKey){\n          mouse.shiftKey   = (event.keyCode === 16);\n        }\n      },\n      \n      keyup : function(event){\n        var mouse = cam.mouse;\n        if(mouse.shiftKey){\n          mouse.shiftKey = (event.keyCode !== 16);\n          if(!mouse.shiftKey){\n            cam.SHIFT_CONSTRAINT = 0;\n          }\n        }\n      }\n      \n    };\n    \n    \n    \n    // camera mouse listeners\n    this.attachMouseListeners();\n   \n    // P5 registered callbacks, TODO unregister on dispose\n    this.auto_update = true;\n    this.P5.registerMethod('pre', function(){\n      if(cam.auto_update){\n        cam.update(); \n      }\n    });\n \n    // damped camera transition\n    this.dampedZoom = new DampedAction(function(d){ cam.zoom   (d * cam.getZoomMult    ()); }  );\n    this.dampedPanX = new DampedAction(function(d){ cam.panX   (d * cam.getPanMult     ()); }  );\n    this.dampedPanY = new DampedAction(function(d){ cam.panY   (d * cam.getPanMult     ()); }  );\n    this.dampedRotX = new DampedAction(function(d){ cam.rotateX(d * cam.getRotationMult()); }  );\n    this.dampedRotY = new DampedAction(function(d){ cam.rotateY(d * cam.getRotationMult()); }  );\n    this.dampedRotZ = new DampedAction(function(d){ cam.rotateZ(d * cam.getRotationMult()); }  );\n    \n    // interpolated camera transition\n    this.timedRot  = new Interpolation(cam.setInterpolatedRotation.bind(cam));\n    this.timedPan  = new Interpolation(cam.setInterpolatedCenter  .bind(cam));\n    this.timedzoom = new Interpolation(cam.setInterpolatedDistance.bind(cam));\n  }\n  \n  \n\n  /**\n   * sets the WEBGL renderer the camera is working on\n   *\n   * @param {p5.RendererGL} renderer ... p5 WEBGL renderer\n   */\n  setCanvas(renderer){\n    if(renderer instanceof p5.RendererGL){\n      // p5js seems to be not very clear about this\n      // ... a bit confusing, so i guess this could change in future releases\n      this.renderer = renderer;\n      if(renderer._pInst instanceof p5){\n        this.graphics = renderer;\n      } else {\n        this.graphics = renderer._pInst;\n      }\n      this.P5 = this.graphics._pInst;\n    } else {\n      this.graphics = undefined;\n      this.renderer = undefined;\n    }\n  }\n\n  /** @return {p5.RendererGL} the currently used renderer */\n  getCanvas(){\n    return this.renderer;\n  }\n  \n  \n  attachListener(el, ev, fx, op){\n    if(!el || (el === fx.el)){\n      return;\n    }\n    \n    this.detachListener(fx);\n\n    fx.el = el;\n    fx.ev = ev;\n    fx.op = op;\n    fx.el.addEventListener(fx.ev, fx, fx.op);\n  }\n  \n  detachListener(fx){\n    if(fx.el) {\n      fx.el.removeEventListener(fx.ev, fx, fx.op);\n      fx.el = undefined;\n    }\n  }\n  \n  /** attaches input-listeners (mouse, touch, key) to the used renderer */\n  attachMouseListeners(renderer){\n    var cam = this.cam;\n    var mouse = cam.mouse;\n    \n    renderer = renderer || cam.renderer;\n    if(renderer){\n      \n      var op = { passive:false };\n      var el = renderer.elt;\n      \n      cam.attachListener(el    , 'mousedown' , mouse.mousedown , op);\n      cam.attachListener(el    , 'mouseup'   , mouse.mouseup   , op);\n      cam.attachListener(el    , 'dblclick'  , mouse.dblclick  , op);\n      cam.attachListener(el    , 'wheel'     , mouse.wheel     , op);\n      cam.attachListener(el    , 'touchstart', mouse.touchstart, op);\n      cam.attachListener(el    , 'touchend'  , mouse.touchend  , op);\n      cam.attachListener(el    , 'touchmove' , mouse.touchmove , op);\n      cam.attachListener(window, 'keydown'   , mouse.keydown   , op);\n      cam.attachListener(window, 'keyup'     , mouse.keyup     , op);\n    }\n  }\n  \n  /** detaches all attached input-listeners */\n  removeMouseListeners(){\n    var cam = this.cam;\n    var mouse = cam.mouse;\n       \n    cam.detachListener(mouse.mousedown );\n    cam.detachListener(mouse.mouseup   );\n    cam.detachListener(mouse.dblclick  );\n    cam.detachListener(mouse.wheel     );\n    cam.detachListener(mouse.keydown   );\n    cam.detachListener(mouse.keyup     );\n    cam.detachListener(mouse.touchstart);\n    cam.detachListener(mouse.touchend  );\n    cam.detachListener(mouse.touchmove );\n  }\n  \n  /** Disposes/releases the camera. */\n  dispose(){\n    // TODO: p5 unregister 'pre', ... not available in 0.5.16\n    removeMouseListeners();\n  }\n  \n  /** @return {boolean} the current autoUpdate state */\n  getAutoUpdate(){\n    return this.auto_update;\n  }\n  /** \n   * If true, the EasyCam will update automatically in a pre-draw step.\n   * This updates the camera state and updates the renderers \n   * modelview/camera matrix.\n   *\n   * If false, the update() needs to be called manually.\n   *\n   * @param {boolean} the new autoUpdate state \n   */\n  setAutoUpdate(status){\n    this.auto_update = status;\n  }\n  \n\n  /** \n   * Updates the camera state (interpolated / damped animations) and updates\n   * the renderers' modelview/camera matrix.\n   *\n   * if \"auto_update\" is true, this is called automatically in a pre-draw call.\n   */\n  update(){\n    var cam = this.cam;\n    var mouse = cam.mouse;\n    \n    mouse.mousedrag();\n\n    var b_update = false;\n    b_update |= cam.dampedZoom.update();\n    b_update |= cam.dampedPanX.update();\n    b_update |= cam.dampedPanY.update();\n    b_update |= cam.dampedRotX.update();\n    b_update |= cam.dampedRotY.update();\n    b_update |= cam.dampedRotZ.update();\n    \n    // interpolated actions have lower priority then damped actions\n    if(b_update){\n      cam.timedRot .stop();\n      cam.timedPan .stop();\n      cam.timedzoom.stop();\n    } else {\n      cam.timedRot .update();\n      cam.timedPan .update();\n      cam.timedzoom.update();\n    }\n \n    cam.apply();\n  }\n  \n  /** \n   * Applies the current camera state to the renderers' modelview/camera matrix.\n   * If no argument is given, then the cameras currently set renderer is used.\n   */\n  apply(renderer) { \n\n    var cam = this.cam;\n    renderer = renderer || cam.renderer;\n    \n    if(renderer){\n      this.camEYE = this.getPosition(this.camEYE);   \n      this.camLAT = this.getCenter  (this.camLAT);\n      this.camRUP = this.getUpVector(this.camRUP);\n      \n      if(undefined===renderer._curCamera)\n        renderer.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2],\n                        this.camLAT[0], this.camLAT[1], this.camLAT[2],\n                        this.camRUP[0], this.camRUP[1], this.camRUP[2]);\n      else\n        renderer._curCamera.camera(this.camEYE[0], this.camEYE[1], this.camEYE[2],\n                        this.camLAT[0], this.camLAT[1], this.camLAT[2],\n                        this.camRUP[0], this.camRUP[1], this.camRUP[2]);\n    }\n\n  }\n  \n\n  /** @param {int[]} the new viewport-def, as [x,y,w,h] */\n  setViewport(viewport){\n    this.viewport = viewport.slice();\n  }\n  \n  /** @returns {int[]} the current viewport-def, as [x,y,w,h] */\n  getViewport(){\n    return this.viewport;\n  }\n  \n  \n\n  //\n  // mouse state changes\n  //\n  \n  /** implemented zoom-cb for mouswheel handler.*/\n  mouseWheelZoom() {\n    var cam = this;\n    var mouse = cam.mouse;\n    cam.dampedZoom.addForce(mouse.mwheel * cam.scale_zoomwheel);\n  }\n  \n  /** implemented zoom-cb for mousedrag/touch handler.*/\n  mouseDragZoom() {\n    var cam = this;\n    var mouse = cam.mouse;\n    cam.dampedZoom.addForce(-mouse.dist[2]);\n  }\n  \n  /** implemented pan-cb for mousedrag/touch handler.*/\n  mouseDragPan() {\n    var cam = this;\n    var mouse = cam.mouse;\n\n    cam.dampedPanX.addForce((cam.DRAG_CONSTRAINT & cam.AXIS.YAW  ) ? mouse.dist[0] : 0);\n    cam.dampedPanY.addForce((cam.DRAG_CONSTRAINT & cam.AXIS.PITCH) ? mouse.dist[1] : 0);\n  }\n  \n  /** implemented rotate-cb for mousedrag/touch handler.*/\n  mouseDragRotate() {\n    var cam = this;\n    var mouse = cam.mouse;\n    \n    var mx = mouse.curr[0], my = mouse.curr[1];\n    var dx = mouse.dist[0], dy = mouse.dist[1];\n\n    // mouse [-1, +1]\n    var mxNdc = Math.min(Math.max((mx - cam.viewport[0]) / cam.viewport[2], 0), 1) * 2 - 1;\n    var myNdc = Math.min(Math.max((my - cam.viewport[1]) / cam.viewport[3], 0), 1) * 2 - 1;\n\n    if (cam.DRAG_CONSTRAINT & cam.AXIS.YAW) {\n      cam.dampedRotY.addForce(+dx * (1.0 - myNdc * myNdc));\n    }\n    if (cam.DRAG_CONSTRAINT & cam.AXIS.PITCH) {\n      cam.dampedRotX.addForce(-dy * (1.0 - mxNdc * mxNdc));\n    }\n    if (cam.DRAG_CONSTRAINT & cam.AXIS.ROLL) {\n      cam.dampedRotZ.addForce(-dx * myNdc);\n      cam.dampedRotZ.addForce(+dy * mxNdc);\n    }\n  }\n  \n  \n  \n  //\n  // damped multipliers\n  //\n  /** (private) returns the used zoom -multiplier for damped actions. */\n  getZoomMult(){\n    return this.state.distance * this.scale_zoom;\n  }\n  /** (private) returns the used pan-multiplier for damped actions. */\n  getPanMult(){\n    return this.state.distance * this.scale_pan;\n  }\n  /** (private) returns the used rotate-multiplier for damped actions. */\n  getRotationMult(){\n    return Math.pow(Math.log10(1 + this.state.distance), 0.5) * this.scale_rotation;\n  }\n  \n  \n  \n  //\n  // damped state changes\n  //\n  /** Applies a change to the current zoom.  */\n  zoom(dz){\n    var cam = this.cam;\n    var distance_tmp = cam.state.distance + dz;\n    \n    // check lower bound\n    if(distance_tmp < cam.distance_min) {\n      distance_tmp = cam.distance_min;\n      cam.dampedZoom.stop();\n    }\n    \n    // check upper bound\n    if(distance_tmp > cam.distance_max) {\n      distance_tmp = cam.distance_max;\n      cam.dampedZoom.stop();\n    }\n    \n    cam.state.distance = distance_tmp;\n  }\n  \n  /** Applies a change to the current pan-xValue.  */\n  panX(dx) {\n    var state = this.cam.state;\n    if(dx) {\n      var val = Rotation.applyToVec3(state.rotation, [dx, 0, 0]);\n      Vec3.add(state.center, val, state.center);\n    }\n  }\n  \n  /** Applies a change to the current pan-yValue.  */\n  panY(dy) {\n    var state = this.cam.state;\n    if(dy) {\n      var val = Rotation.applyToVec3(state.rotation, [0, dy, 0]);\n      Vec3.add(state.center, val, state.center);\n    }\n  }\n  \n  /** Applies a change to the current pan-value.  */\n  pan(dx, dy) {\n    this.cam.panX(dx);\n    this.cam.panY(dx);\n  }\n  \n  /** Applies a change to the current xRotation.  */\n  rotateX(rx) {\n   this.cam.rotate([1,0,0], rx);\n  }\n  \n  /** Applies a change to the current yRotation.  */\n  rotateY(ry) {\n    this.cam.rotate([0,1,0], ry);\n  }\n  \n  /** Applies a change to the current zRotation.  */\n  rotateZ(rz) {\n    this.cam.rotate([0,0,1], rz);\n  }\n  \n  /** Applies a change to the current rotation, using the given axis/angle.  */\n  rotate(axis, angle) {\n    var state = this.cam.state;\n    if(angle) {\n      var new_rotation = Rotation.create({axis:axis, angle:angle});\n      Rotation.applyToRotation(state.rotation, new_rotation, state.rotation);\n    }\n  }\n  \n  \n  \n\n  // \n  // interpolated states\n  //\n  /** Sets the new camera-distance, interpolated (t) between given A and B. */\n  setInterpolatedDistance(valA, valB, t) {\n    this.cam.state.distance = Scalar.mix(valA, valB, Scalar.smoothstep(t));\n  }\n  /** Sets the new camera-center, interpolated (t) between given A and B. */\n  setInterpolatedCenter(valA, valB, t) {\n    this.cam.state.center = Vec3.mix(valA, valB, Scalar.smoothstep(t));\n  }\n  /** Sets the new camera-rotation, interpolated (t) between given A and B. */\n  setInterpolatedRotation(valA, valB, t) {\n    this.cam.state.rotation = Rotation.slerp(valA, valB, t);\n  }\n  \n  \n  \n  //\n  // DISTANCE\n  //\n  /** Sets the minimum camera distance. */\n  setDistanceMin(distance_min) {\n    this.distance_min = Math.max(distance_min, this.distance_min_limit);\n    this.zoom(0); // update, to ensure new minimum\n  }\n  \n  /** Sets the maximum camera distance. */\n  setDistanceMax(distance_max) {\n    this.distance_max = distance_max;\n    this.zoom(0); // update, to ensure new maximum\n  }\n  \n  /** \n   * Sets the new camera distance.\n   *\n   * @param {double} new distance.\n   * @param {long} animation time in millis.\n   */\n  setDistance(distance, duration) {\n    this.timedzoom.start(this.state.distance, distance, duration, [this.dampedZoom]);\n  }\n  \n  /** @returns {double} the current camera distance. */\n  getDistance() {\n    return this.state.distance;\n  }\n  \n  \n  \n  //\n  // CENTER / LOOK AT\n  //\n  /** \n   * Sets the new camera center.\n   *\n   * @param {double[]} new center.\n   * @param {long} animation time in millis.\n   */\n  setCenter(center, duration) {\n    this.timedPan.start(this.state.center, center, duration, [this.dampedPanX, this.dampedPanY]);\n  }\n  \n  /** @returns {double[]} the current camera center. */\n  getCenter() {\n    return this.state.center;\n  }\n  \n  \n  \n  //\n  // ROTATION\n  //\n  /** \n   * Sets the new camera rotation (quaternion).\n   *\n   * @param {double[]} new rotation as quat[q0,q1,q2,q3].\n   * @param {long} animation time in millis.\n   */\n  setRotation(rotation, duration) {\n    this.timedRot.start(this.state.rotation, rotation, duration, [this.dampedRotX, this.dampedRotY, this.dampedRotZ]);\n  }\n  \n  /** @returns {double[]} the current camera rotation as quat[q0,q1,q2,q3]. */\n  getRotation() {\n    return this.state.rotation;\n  }\n  \n\n\n  //\n  // CAMERA POSITION/EYE\n  //\n  /** @returns {double[]} the current camera position, aka. the eye position. */\n  getPosition(dst) {\n\n    var cam = this.cam;\n    var state = cam.state;\n    \n    dst = Vec3.assert(dst);\n    Rotation.applyToVec3(state.rotation, cam.LOOK, dst);\n    Vec3.mult(dst, state.distance, dst);\n    Vec3.add(dst, state.center, dst);\n\n    return dst;\n  }\n\n  //\n  // CAMERA UP\n  //\n  /** @returns {double[]} the current camera up vector. */\n  getUpVector(dst) {\n    var cam = this.cam;\n    var state = cam.state;\n    dst = Vec3.assert(dst);\n    Rotation.applyToVec3(state.rotation, cam.UP, dst);\n    return dst;\n  }\n  \n  \n  \n  \n  \n\n  //\n  // STATE (rotation, center, distance)\n  //\n  /** @returns {Object} a copy of the camera state {distance,center,rotation} */\n  getState() {\n    return this.state.copy();\n  }  \n  /** \n   * @param {Object} a new camera state {distance,center,rotation}.\n   * @param {long} animation time in millis.\n   */\n  setState(other, duration) {\n    if(other){\n      this.setDistance(other.distance, duration);\n      this.setCenter  (other.center  , duration);\n      this.setRotation(other.rotation, duration);\n    }\n  }\n\n  pushState(){\n    return (this.state_pushed = this.getState());\n  }\n  popState(duration){\n    this.setState(this.state_pushed, duration);\n  }\n  \n  /** sets the current state as reset-state. */\n  pushResetState(){\n    return (this.state_reset = this.getState());\n  }\n  /** resets the camera, by applying the reset-state. */\n  reset(duration){\n    this.setState(this.state_reset, duration);\n  }\n  \n  \n  \n  \n  \n\n  \n  \n  /** sets the rotation scale/speed. */\n  setRotationScale(scale_rotation){\n    this.scale_rotation = scale_rotation;\n  }\n  /** sets the pan scale/speed. */\n  setPanScale(scale_pan){\n    this.scale_pan = scale_pan;\n  }\n  /** sets the zoom scale/speed. */\n  setZoomScale(scale_zoom){\n    this.scale_zoom = scale_zoom;\n  }\n  /** sets the wheel scale/speed. */\n  setWheelScale(wheelScale) {\n    this.scale_zoomwheel = wheelScale;\n  }\n  /** @returns the rotation scale/speed. */\n  getRotationScale(){\n    return this.scale_rotation;\n  }\n  /** @returns the pan scale/speed. */\n  getPanScale() {\n    return this.scale_pan;\n  }\n  /** @returns the zoom scale/speed. */\n  getZoomScale() {\n    return this.scale_zoom;\n  }\n  /** @returns the wheel scale/speed. */\n  getWheelScale() {\n    return this.scale_zoomwheel;\n  }\n  \n  /** sets the default damping scale/speed. */\n  setDamping(damping) {\n    this.dampedZoom.damping = damping;\n    this.dampedPanX.damping = damping;\n    this.dampedPanY.damping = damping;\n    this.dampedRotX.damping = damping;\n    this.dampedRotY.damping = damping;\n    this.dampedRotZ.damping = damping;\n  }\n  /** sets the default interpolation time in millis. */\n  setDefaultInterpolationTime(duration) {\n    this.timedRot .default_duration = duration;\n    this.timedPan .default_duration = duration;\n    this.timedzoom.default_duration = duration;\n  }\n  \n  \n  /** \n   * sets the rotation constraint for each axis separately.\n   *\n   * @param {boolean} yaw constraint\n   * @param {boolean} pitch constraint\n   * @param {boolean} roll constraint\n   */\n  setRotationConstraint(yaw, pitch, roll) {\n    var cam = this.cam;\n    cam.FIXED_CONSTRAINT  = 0;\n    cam.FIXED_CONSTRAINT |= yaw   ? cam.AXIS.YAW   : 0;\n    cam.FIXED_CONSTRAINT |= pitch ? cam.AXIS.PITCH : 0;\n    cam.FIXED_CONSTRAINT |= roll  ? cam.AXIS.ROLL  : 0;\n  }\n  \n\n \n  /**\n   * \n   * begin screen-aligned 2D-drawing.\n   * \n   * <pre>\n   * beginHUD()\n   *   disabled depth test\n   *   ortho\n   *   ... your code is executed here ...\n   * endHUD()\n   * </pre>\n   * \n   */\n  beginHUD(renderer, w, h) {\n    var cam = this.cam;\n    renderer = renderer || cam.renderer;\n    \n    if(!renderer) return;\n    this.pushed_rendererState = renderer.push();\n    \n    var gl = renderer.drawingContext;\n    var w = (w !== undefined) ? w : renderer.width;\n    var h = (h !== undefined) ? h : renderer.height;\n    var d = Number.MAX_VALUE;\n    \n    gl.flush();\n    // gl.finish();\n    \n    // 1) disable DEPTH_TEST\n    gl.disable(gl.DEPTH_TEST);\n    // 2) push modelview/projection\n    //    p5 is not creating a push/pop stack\n    this.pushed_uMVMatrix = renderer.uMVMatrix.copy();\n    this.pushed_uPMatrix  = renderer.uPMatrix .copy();\n    \n    // 3) set new modelview (identity)\n    renderer.resetMatrix();\n    // 4) set new projection (ortho)\n    renderer._curCamera.ortho(0, w, -h, 0, -d, +d);\n    // renderer.ortho();\n    // renderer.translate(-w/2, -h/2);\n\n  }\n  \n  \n\n  /**\n   * \n   * end screen-aligned 2D-drawing.\n   * \n   */\n  endHUD(renderer) {\n    var cam = this.cam;\n    renderer = renderer || cam.renderer;\n    \n    if(!renderer) return;\n    \n    var gl = renderer.drawingContext;\n    \n    gl.flush();\n    // gl.finish();\n      \n    // 2) restore modelview/projection\n    renderer.uMVMatrix.set(this.pushed_uMVMatrix);\n    renderer.uPMatrix .set(this.pushed_uPMatrix );\n    // 1) enable DEPTH_TEST\n    gl.enable(gl.DEPTH_TEST);\n    renderer.pop(this.pushed_rendererState);\n  }\n\n  \n  \n}\n\n\n\n\n\n\n\n\n/**\n * Damped callback, that accepts the resulting damped/smooth value.\n *\n * @callback dampedCallback\n * @param {double} value - the damped/smoothed value\n *\n */\n\n \n/**\n *\n * DampedAction, for smoothly changing a value to zero.\n *\n * @param {dampedCallback} cb - callback that accepts the damped value as argument.\n */\nclass DampedAction {\n  \n  \n  /**  @constructor */\n  constructor(cb){\n    this.value = 0.0;\n    this.damping = 0.85;\n    this.action = cb;\n  }\n\n  /** adds a value to the current value beeing damped. \n   * @param {double} force - the value beeing added.\n   */\n  addForce(force) {\n    this.value += force;\n  }\n\n  /** updates the damping and calls {@link damped-callback}. */\n  update() {\n    var active = (this.value*this.value) > 0.000001;\n    if (active){\n      this.action(this.value);\n      this.value *= this.damping;\n    } else {\n      this.stop();\n    }\n    return active;\n  }\n  \n  /** stops the damping. */\n  stop() {\n    this.value = 0.0;\n  }\n\n}\n\n\n\n\n/**\n * Interpolation callback, that implements any form of interpolation between\n * two values A and B and the interpolationparameter t.\n * <pre>\n *   linear: A * (1-t) + B * t\n *   smooth, etc...\n * </pre>\n * @callback interpolationCallback\n * @param {Object} A - First Value\n * @param {Object} B - Second Value\n * @param {double} t - interpolation parameter [0, 1]\n *\n */\n\n\n/**\n *\n * Interpolation, for smoothly changing a value by interpolating it over time.\n *\n * @param {interpolationCallback} cb - callback for interpolating between two values.\n */\nclass Interpolation {\n  \n  /**  @constructor */\n  constructor(cb){\n    this.default_duration = 300;\n    this.action = cb;\n  }\n  \n  /** starts the interpolation.\n   *  If the given interpolation-duration is 0, then\n   * {@link interpolation-callback} is called immediately.\n   */\n  start(valA, valB, duration, actions) {\n    for(var x in actions){\n      actions[x].stop();\n    }\n    this.valA = valA;\n    this.valB = valB;\n    this.duration = (duration === undefined) ? this.default_duration : duration;\n    this.timer = new Date().getTime();\n    this.active = this.duration > 0;\n    if(!this.active){\n      this.interpolate(1);\n    }\n  }\n  \n  /** updates the interpolation and calls {@link interpolation-callback}.*/\n  update() {\n    if(this.active){\n      var t = (new Date().getTime() - this.timer) / this.duration;\n      if (t > 0.995) {\n        this.interpolate(1);\n        this.stop();\n      } else {\n        this.interpolate(t);\n      }\n    }\n  }\n  \n  interpolate(t){\n    this.action(this.valA, this.valB, t);\n  }\n  \n  /** stops the interpolation. */\n  stop() {\n    this.active = false;\n  }\n\n}\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// ROTATION (Quaternion)\n//\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Rotation as Quaternion [q0, q1, q2, q3]\n *\n * Note: Only functions that were required for the EasyCam to work are implemented.\n * \n * @namespace\n */\nvar Rotation = \n{\n  \n  assert : function(dst){\n    return ((dst === undefined) || (dst.constructor !== Array)) ? [1, 0, 0, 0] : dst;\n  },\n  \n  /** @returns {Number[]} an identity rotation [1,0,0,0] */\n  identity : function() {\n    return [1, 0, 0, 0];\n  },\n  \n  /** \n   * Applies the rotation to a vector and returns dst or a new vector.\n   *\n   * @param {Number[]} rot - Rotation (Quaternion)\n   * @param {Number[]} vec - vector to be rotated by rot\n   * @param {Number[]} dst - resulting vector\n   * @returns {Number[]} dst- resulting vector\n   */\n  applyToVec3 : function(rot, vec, dst) {\n    \n    var [x,y,z] = vec;\n    var [q0,q1,q2,q3] = rot;\n    \n    var s = q1 * x + q2 * y + q3 * z;\n    \n    dst = Vec3.assert(dst);\n    dst[0] = 2 * (q0 * (x * q0 - (q2 * z - q3 * y)) + s * q1) - x; \n    dst[1] = 2 * (q0 * (y * q0 - (q3 * x - q1 * z)) + s * q2) - y; \n    dst[2] = 2 * (q0 * (z * q0 - (q1 * y - q2 * x)) + s * q3) - z;\n    return dst;\n  },\n  \n  /** \n   * Applies the rotation to another rotation and returns dst or a new rotation.\n   *\n   * @param {Number[]} rotA - RotationA (Quaternion)\n   * @param {Number[]} rotB - RotationB (Quaternion)\n   * @param {Number[]} dst - resulting rotation\n   * @returns {Number[]} dst - resulting rotation\n   */\n  applyToRotation(rotA, rotB, dst) {\n    var [a0,a1,a2,a3] = rotA;\n    var [b0,b1,b2,b3] = rotB;\n    \n    dst = Rotation.assert(dst);\n    dst[0] = b0 * a0 - (b1 * a1 +  b2 * a2 + b3 * a3);\n    dst[1] = b1 * a0 +  b0 * a1 + (b2 * a3 - b3 * a2);\n    dst[2] = b2 * a0 +  b0 * a2 + (b3 * a1 - b1 * a3);\n    dst[3] = b3 * a0 +  b0 * a3 + (b1 * a2 - b2 * a1);\n    return dst;     \n  },\n  \n  \n  /** \n   * Interpolates a rotation.\n   *\n   * @param {Number[]} rotA - RotationA (Quaternion)\n   * @param {Number[]} rotB - RotationB (Quaternion)\n   * @param {Number  } t - interpolation parameter\n   * @param {Number[]} dst - resulting rotation\n   * @returns {Number[]} dst - resulting rotation\n   */\n  slerp : function(rotA, rotB, t, dst) {\n    var [a0,a1,a2,a3] = rotA;\n    var [b0,b1,b2,b3] = rotB;\n    \n    var cosTheta = a0 * b0 + a1 * b1 + a2 * b2 + a3 * b3;\n    if (cosTheta < 0) {\n      b0 = -b0;\n      b1 = -b1;\n      b2 = -b2;\n      b3 = -b3;\n      cosTheta = -cosTheta;\n    }\n    \n    var theta = Math.acos(cosTheta);\n    var sinTheta = Math.sqrt(1.0 - cosTheta * cosTheta);\n    \n    var w1, w2;\n    if (sinTheta > 0.001) {\n      w1 = Math.sin((1.0 - t) * theta) / sinTheta;\n      w2 = Math.sin(t * theta) / sinTheta;\n    } else {\n      w1 = 1.0 - t;\n      w2 = t;\n    }\n    \n    dst = Rotation.assert(dst);\n    dst[0] = w1 * a0 + w2 * b0; \n    dst[1] = w1 * a1 + w2 * b1; \n    dst[2] = w1 * a2 + w2 * b2; \n    dst[3] = w1 * a3 + w2 * b3;\n    \n    return Rotation.create({rotation : dst, normalize : true}, dst);\n  },\n  \n  /** \n   * Creates/Initiates a new Rotation\n   *\n   * <pre>\n   *\n   *    1) Axis,Angle:\n   *       {\n   *         axis : [x, y, z],\n   *         angle: double\n   *       }\n   *      \n   *    2) Another Rotation:\n   *       {\n   *         rotation : [q0, q1, q2, q3],\n   *         normalize: boolean\n   *       }\n   *      \n   *    3) 3 euler angles, XYZ-order:\n   *       {\n   *         angles_xyz : [rX, rY, rZ]\n   *       }\n   *   \n   * </pre>\n   *\n   *\n   * @param {Object} def - Definition, for creating the new Rotation\n   * @param {Number[]} dst - resulting rotation\n   * @returns {Number[]} dst - resulting rotation\n   */\n  create : function(def, dst) {\n    \n    dst = Rotation.assert(dst);\n    \n    // 1) from axis and angle\n    if(def.axis)\n    {\n      var axis = def.axis;\n      var angle = def.angle;\n    \n      var norm = Vec3.mag(axis);\n      if (norm == 0.0) return; // vector is of zero length\n      \n      var halfAngle = -0.5 * angle;\n      var coeff = Math.sin(halfAngle) / norm;\n\n      dst[0] = Math.cos(halfAngle);\n      dst[1] = coeff * axis[0];\n      dst[2] = coeff * axis[1];\n      dst[3] = coeff * axis[2];\n      return dst;\n    }\n    \n    // 2) from another rotation\n    if(def.rotation)\n    {\n      dst[0] = def.rotation[0];\n      dst[1] = def.rotation[1];\n      dst[2] = def.rotation[2];\n      dst[3] = def.rotation[3];\n      \n      if(def.normalize){\n        var inv = 1.0 / Math.sqrt(dst[0]*dst[0] + dst[1]*dst[1] + dst[2]*dst[2] + dst[3]*dst[3]);\n        dst[0] *= inv;\n        dst[1] *= inv;\n        dst[2] *= inv;\n        dst[3] *= inv;\n      }\n       \n      return dst;\n    }\n    \n    // 3) from 3 euler angles, order XYZ\n    if(def.angles_xyz){\n      \n      var ax = -0.5 *  def.angles_xyz[0];\n      var ay = -0.5 *  def.angles_xyz[1];\n      var az = -0.5 *  def.angles_xyz[2];\n      \n      var rotX = [Math.cos(ax), Math.sin(ax), 0, 0];\n      var rotY = [Math.cos(ay), 0, Math.sin(ay), 0];\n      var rotZ = [Math.cos(az), 0, 0, Math.sin(az)];\n      \n      Rotation.applyToRotation(rotY, rotZ, dst);\n      Rotation.applyToRotation(rotX, dst, dst);\n \n      return dst;\n    }\n\n\n  }\n  \n  \n  //\n  // ... to be continued ...\n  //\n  \n};\n\n\n\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// SCALAR\n//\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Scalar as a simple number.\n *\n * Note: Only functions that were required for the EasyCam to work are implemented.\n *\n * @namespace\n */\nvar Scalar = {\n  \n  /**\n   * Linear interpolation between A and B using t[0,1]\n   */\n  mix : function(a, b, t){\n    return a * (1-t) + b * t;\n  },\n     \n  /**\n   * modifying t as a function of smoothstep(0,1,t);\n   */\n  smoothstep : function(x) {\n    return x * x * (3 - 2 * x);\n  },\n  \n  /**\n   * modifying t as a function of smootherstep(0,1,t);\n   */\n  smootherstep : function(t) {\n    return x * x * x * (x * (x * 6 - 15) + 10);\n  },\n  \n};\n\n\n\n\n\n////////////////////////////////////////////////////////////////////////////////\n//\n// VEC3\n//\n////////////////////////////////////////////////////////////////////////////////\n/**\n * Vec3 as a 3D vector (Array)\n *\n * @namespace\n */\nvar Vec3 = \n{\n  \n  assert : function(dst){\n    return ((dst === undefined) || (dst.constructor !== Array)) ? [0, 0, 0] : dst;\n  },\n  \n  isScalar : function(arg){\n    // TODO: do some profiling to figure out what fails\n    return (arg !== undefined) && (arg.constructor !== Array);\n    // return typeof(arg) === 'number';\n  },\n  \n  /** addition: <pre> dst = a + b </pre>  */\n  add : function(a, b, dst) {\n    dst = this.assert(dst);\n    if(this.isScalar(b)){\n      dst[0] = a[0] + b;\n      dst[1] = a[1] + b;\n      dst[2] = a[2] + b;\n    } else {\n      dst[0] = a[0] + b[0];\n      dst[1] = a[1] + b[1];\n      dst[2] = a[2] + b[2];\n    }\n    return dst;\n  },\n\n  /** componentwise multiplication: <pre> dst = a * b </pre>  */\n  mult : function(a, b, dst){\n    dst = this.assert(dst);\n    if(this.isScalar(b)){\n      dst[0] = a[0] * b;\n      dst[1] = a[1] * b;\n      dst[2] = a[2] * b;\n    } else {\n      dst[0] = a[0] * b[0];\n      dst[1] = a[1] * b[1];\n      dst[2] = a[2] * b[2];\n    }\n    return dst;\n  },\n\n  /** squared length  */\n  magSq : function(a) {\n    return a[0]*a[0] + a[1]*a[1] + a[2]*a[2];\n  },\n  \n  /** length  */\n  mag : function(a) {\n    return Math.sqrt(a[0]*a[0] + a[1]*a[1] + a[2]*a[2]);\n  },\n  \n  /** dot-product  */\n  dot : function(a, b) {\n    return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];\n  },\n  \n  /** cross-product  */\n  cross : function(a, b, dst) {\n    dst = this.assert(dst);\n    dst[0] = a[1] * b[2] - a[2] * b[1];\n    dst[1] = a[2] * b[0] - a[0] * b[2];\n    dst[2] = a[0] * b[1] - a[1] * b[0];\n    return dst;\n  },\n\n  /** angle  */\n  angle : function(v1, v2){\n\n    var normProduct = this.mag(v1) * this.mag(v2);\n    if (normProduct === 0.0) {\n      return 0.0; // at least one vector is of zero length\n    }\n    \n    var dot = this.dot(v1, v2);\n    var threshold = normProduct * 0.9999;\n    if ((dot < -threshold) || (dot > threshold)) {\n      // the vectors are almost aligned, compute using the sine\n      var v3 = this.cross(v1, v2);\n      if (dot >= 0) {\n        return Math.asin(this.mag(v3) / normProduct);\n      } else {\n        return Math.PI - Math.asin(this.mag(v3) / normProduct);\n      }\n    }\n    \n    // the vectors are sufficiently separated to use the cosine\n    return Math.acos(dot / normProduct);\n  },\n  \n  /** linear interpolation: <pre> dst = a * (1 - t) + b * t </pre> */\n  mix(a, b, t, dst) {\n    dst = this.assert(dst);\n    dst[0] = Scalar.mix(a[0], b[0], t); \n    dst[1] = Scalar.mix(a[1], b[1], t);\n    dst[2] = Scalar.mix(a[2], b[2], t);\n    return dst;\n  },\n  \n  \n  //\n  // ... to be continued ...\n  //\n  \n};\n\n\n\n\n\n\n\n\n  \n////////////////////////////////////////////////////////////////////////////////\n//\n// public objects\n//\n////////////////////////////////////////////////////////////////////////////////\n\n/**\n * @static\n */\nEasyCam.INFO = INFO; // make static\nObject.freeze(INFO); // and constant\n\n\next = (ext !== undefined) ? ext : {};\n\n/**\n * @memberof Dw\n */\next.EasyCam = EasyCam;\n/**\n * @memberof Dw\n */\next.DampedAction = DampedAction;\n/**\n * @memberof Dw\n */\next.Interpolation = Interpolation;\n/**\n * @memberof Dw\n */\next.Rotation = Rotation;\n/**\n * @memberof Dw\n */\next.Vec3 = Vec3;\n/**\n * @memberof Dw\n */\next.Scalar = Scalar;\n\nreturn ext;\n  \n\n})(Dw);\n\n\n\n/**\n * @submodule Camera\n * @for p5\n */\n\nif(p5){\n  \n    \n  /**\n   * p5.EasyCam creator function. \n   * Arguments are optional, and equal to the default EasyCam constructor.\n   * @return {EasyCam} a new EasyCam\n   */\n  p5.prototype.createEasyCam = function(/* p5.RendererGL, {state} */){\n    \n    var renderer = this._renderer;\n    var args     = arguments[0];\n    \n    if(arguments[0] instanceof p5.RendererGL){\n      renderer = arguments[0];\n      args     = arguments[1]; // could still be undefined, which is fine\n    } \n    \n    return new Dw.EasyCam(renderer, args); \n  }\n}"]},"metadata":{},"sourceType":"script"}